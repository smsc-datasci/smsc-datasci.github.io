[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Module one: Course tools",
    "section": "",
    "text": "Module overview\n\nWelcome to Managing Ecological Data in R: Introduction to Data Science and the Art of Wrangling for Ecologists! In this course, we will explore the management of ecological data using Program R. You will gain an in-depth understanding of how to apply the tidyverse to efficiently wrangle ecological data.We will focus on the structure and linguistics of data in R, how to integrate R into a modern data science workflow, and explore how to think about ecological data in new ways.\n\n\nPreliminary course content\nPrior to starting this module, I strongly suggest completing the preliminary course material. The lessons are designed to assist R beginners in getting a baseline familiarity with key R programming concepts and serve as an important refresher for those already working regularly in R. Even if you’re coming in with loads of R experience, you’ll almost certainly learn a thing or two along the way!\n\nLesson 1: Introduction to R and RStudio\nLesson 2: Values\nLesson 3: Objects\nLesson 4: Indexing\n\n\n\n\nWhat you will learn\nThis module is divided into seven sections:\n\nCourse introduction: A general introduction to the content of this course, where to find course resources, and how to navigate course content.\nGetting started: This section provides necessary steps that you must take prior to completing the content of this module. Each module will begin with a section like this and the steps therein must be followed carefully!\nImporting, exploring, and exporting data: How to read in different file formats, exploratory steps that should be taken every time you read in a file, and how to write files to your hard drive.\nCore dplyr verbs and when to use them:\nUsing the pipe for chained operations: The pipe allows us to chain together steps of a multi-step process. Using pipes in our code helps us better manage our global environment and generates code that is more concise, organized, and communicative.\nIntroduction to data visualization: We’ll be visualizing data a lot throughout this course. This video introduces you to ggplot, the package we will use for many of our data visualizations.\nBest practices in code formatting: This concise document provides a set of rules to follow to ensure that you have consistent, communicable code.\n\n\n\n\nResources\nElements of this course may be challenging, but help is on the way!\n\nThe course Discussion board is a great peer-to-peer learning resource and should be your first stop if you are having difficulty!\nR for Data Science (https://r4ds.hadley.nz/) is our primary textbook for this course. Written by the Posit team, this book will help clarify course concepts. I will also post required readings throughout the semester to supplement course materials.\nVirtual office hour sessions are offered to provide one-on-one help with course materials.\nPlease contact us via email if you find an error in the content or require assistance with course logistics.\n\nBrian Evans: evansbr@si.edu\nJoe Kolowski: kolowskij@si.edu"
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "2  Getting started",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "index.html#preliminary-course-content",
    "href": "index.html#preliminary-course-content",
    "title": "Module one: Course tools",
    "section": "Preliminary course content",
    "text": "Preliminary course content\nPrior to starting this module, I strongly suggest completing the preliminary course material. The lessons are designed to assist R beginners in getting a baseline familiarity with key R programming concepts and serve as an important refresher for those already working regularly in R. Even if you’re coming in with loads of R experience, you’ll almost certainly learn a thing or two along the way!\n\nLesson 1: Introduction to R and RStudio\nLesson 2: Values\nLesson 3: Objects\nLesson 4: Indexing"
  },
  {
    "objectID": "index.html#module-one-course-tools",
    "href": "index.html#module-one-course-tools",
    "title": "Module one: Course tools",
    "section": "Module one: Course tools",
    "text": "Module one: Course tools\nThis module is divided into seven sections:\n\nCourse introduction: A general introduction to the content of this course, where to find course resources, and how to navigate course content.\nGetting started: This section provides necessary steps that you must take prior to completing the content of this module. Each module will begin with a section like this and the steps therein must be followed carefully!\nImporting, exploring, and exporting data: How to read in different file formats, exploratory steps that should be taken every time you read in a file, and how to write files to your hard drive.\nCore dplyr verbs and when to use them:\nUsing the pipe for chained operations:\nIntroduction to data visualization with ggplot\nBest practices in code formatting:\n\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#module-contents",
    "href": "index.html#module-contents",
    "title": "Module one: Course tools",
    "section": "Module contents",
    "text": "Module contents\nThis module is divided into seven sections:\n\nCourse introduction: A general introduction to the content of this course, where to find course resources, and how to navigate course content.\nGetting started: This section provides necessary steps that you must take prior to completing the content of this module. Each module will begin with a section like this and the steps therein must be followed carefully!\nImporting, exploring, and exporting data: How to read in different file formats, exploratory steps that should be taken every time you read in a file, and how to write files to your hard drive.\nCore dplyr verbs and when to use them:\nUsing the pipe for chained operations:\nIntroduction to data visualization with ggplot\nBest practices in code formatting:\n\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#what-you-will-learn",
    "href": "index.html#what-you-will-learn",
    "title": "Module one: Course tools",
    "section": "What you will learn",
    "text": "What you will learn\nThis module is divided into seven sections:\n\nCourse introduction: A general introduction to the content of this course, where to find course resources, and how to navigate course content.\nGetting started: This section provides necessary steps that you must take prior to completing the content of this module. Each module will begin with a section like this and the steps therein must be followed carefully!\nImporting, exploring, and exporting data: How to read in different file formats, exploratory steps that should be taken every time you read in a file, and how to write files to your hard drive.\nCore dplyr verbs and when to use them:\nUsing the pipe for chained operations:\nIntroduction to data visualization with ggplot\nBest practices in code formatting:\n\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#module-overview",
    "href": "index.html#module-overview",
    "title": "Module one: Course tools",
    "section": "Module overview",
    "text": "Module overview\n\nWelcome to Managing Ecological Data in R: Introduction to Data Science and the Art of Wrangling for Ecologists! In this course, we will explore the management of ecological data using Program R. You will gain an in-depth understanding of how to apply the tidyverse to efficiently wrangle ecological data. We will focus on the structure and linguistics of data in R, how to integrate R into a modern data science workflow, and explore how to think about ecological data in new ways.\nIn this module, we will cover the basic concepts and primary tools that we will use in this course. We will quickly build on the content herein, so please be sure to read/view all content in the order that it appears.\nThis module is divided into eight sections:\n\nCourse introduction: A general introduction to the content of this course, where to find course resources, and how to navigate course content.\nBefore you begin: This section provides necessary steps that you must take prior to completing the content of this module. You will set your global options for this course and learn what I mean by “please ensure that you are working in a clean session” (you will hear me say this a lot).\nObjects: In this lesson, we will review functions and how to create and describe the most common data objects that we will use in this course (atomic vectors, lists, and data frames).\nImporting and exporting data: Here, we will review how to import and export in .csv and .rds files, you will learn how to read in .xlsx files, and I will describe exploratory steps that should be taken every time you read in a file.\nAssignment: In this lesson, we’ll review global (and “local”) assignments, you’ll learn the benefits and pitfalls of global assignments. Along the way, you learn how to use base R’s pipe operator and I will provide recommendations to improve your R workflow and manage your global environment.\nCore dplyr verbs and when to use them: We will break new ground with this lesson as we learn how and when to use the primary dplyr functions for manipulating data frames. Functions covered include mutate(), select(), filter(), summarize(), and arrange().\nIntroduction to data visualization: We will be visualizing data a lot throughout this course. This lesson introduces you to ggplot2, the package we will use for visualizing data. I will introduce some of the underlying theory behind the Grammar of Graphics, apply this theory to a few plots, and you will learn how to make simple plots.\nCourse style guide: Modern standards in R coding compel us to generate code that consistent, parsimonious, and communicable. This lesson provides the set of code formatting rules that I ask you to follow in the course. The provided rules are closely aligned with the tidyverse style guide."
  },
  {
    "objectID": "course_introduction.html",
    "href": "course_introduction.html",
    "title": "1  Course introduction",
    "section": "",
    "text": "1.0.1 Getting help\nElements of this course may be challenging, but help is on the way!\n\nThe course Discussion board is a great peer-to-peer learning resource and should be your first stop if you are having difficulty!\nR for Data Science (https://r4ds.hadley.nz/) is our primary textbook for this course. Written by the Posit team, this book will help clarify course concepts. I will also post required readings throughout the semester to supplement course materials.\nQuestion & Answer sessions are offered every Friday and are meant to help you with your weekly problem sets.\nWeekly review sessions are offered every Monday. In these sessions we review the problem set key and address any questions that you may have.\nVirtual office hour sessions are offered to provide one-on-one help with course materials.\nPlease contact us via email if you find an error in the content or require assistance with course logistics.\n\nBrian Evans: evansbr@si.edu\nJoe Kolowski: kolowskij@si.edu"
  },
  {
    "objectID": "reading_writing.html#overview",
    "href": "reading_writing.html#overview",
    "title": "3  Importing, exploring, and exporting data",
    "section": "3.1 Overview",
    "text": "3.1 Overview\nMaterial covered in this lesson includes:\n\nStarting an RStudio session\nWhy work in a project?\nReading data\nCreating data from scratch\nFunctions for data exploration\nWriting data"
  },
  {
    "objectID": "reading_writing.html#reference-material",
    "href": "reading_writing.html#reference-material",
    "title": "4  Importing & exporting",
    "section": "4.6 Reference material",
    "text": "4.6 Reference material\nBelow is some handy reference material for content covered in this lesson.\n\n4.6.1 Glossary of terms\n\nAssignment (noun): A reference point in your global environment that R can use to retrieve an object located within your computer’s memory.\nAssignment (verb): The act of assigning a reference (also called a name, key, binding, or assignment) to your global environment that R can use to retrieve an object located within your computer’s memory.\nCode section: A portion of a script that is delineated by a section header (Windows: Ctrl + Shift + R; Mac: Command + Shift + R)\nCore package: A package that is loaded when its parent metapackage is loaded.\nGarbage collection: The process by which R frees up memory by deleting objects that are not named in the global environment\nGlobal Environment: The location where object names are stored locally during the current session\nList item: Individual values or component objects of a list.\nMenu bar: The bar at the top of the RStudio window\nPane: The RStudio window is divided into four sections, called panes\nRelative file path: The path to a file relative to the working directory\nSession: Everything you do in RStudio in a single sitting\nTab: Each pane has a tab on the top of it. For example, I will often refer to the Environment or History tabs of the workspace pane.\nWorking directory: The location on your computer’s operating system where R will attempt to read or write files\n\n\n\n4.6.2 R Studio panes\nThroughout this class, I will refer to the panes (sections) of the R Studio window. This graphic should help you remember them:\n\n\n\n4.6.3 Keyboard shortcuts\nThe Keyboard shortcuts we will use in this lesson are listed below for Windows and Mac operating systems.\n\n   I strongly suggest using a keyboard shortcut whenever possible. It can be hard to do at first, using your mouse to click a button or typing a few characters is initially way easier than remembering the keyboard shortcut. If you force yourself to do it though, you won”t regret it – it saves a lot of time in the end.\n\n\nKeyboard shortcuts\n\n\n\n\n\n\n\nTask\nWindows\nMac\n\n\n\n\nCreate a new script\nControl + Shift + N\nCommand + Shift + N\n\n\nView all keyboard shortcuts\nCtrl + Alt + K\nCommand + Option + K\n\n\nExecute code\nCtrl + Enter\nCommand + Enter\n\n\nAdd an assignment operator\nAlt + Dash\nOption + Dash\n\n\nSave script file\nControl + S\nCommand + S\n\n\nCopy\nControl + C\nCommand + C\n\n\nPaste\nControl + V\nCommand + V\n\n\n\n\n\n4.6.4 Functions used in this lesson\n\n4.6.4.1 Base R functions:\n\nc\ndata.frame\ndim\nfile.remove\nlength\nlevels\nlibrary\nlist\nlist.files\nls\nmax\nmean\nmedian\nmin\nnrow\nncol\nread.csv (do not use!)\nrm\nsd\nsetwd (do not use!)\nstr\nsummary\ntable\nunique\nvar\nview (do not use!)\nwrite.csv (do not use!)\n\n\n\n4.6.4.2 Tidyverse\nWe used the tidyverse packages dplyr, readr, and tibble in this lesson. Each of these packages are members of the core tidyverse – that means that the packages are loaded, by default, with library(tidyverse).\n\ndplyr::arrange\ndplyr::desc\ndplyr::bind_cols\ndplyr::slice_head\ndplyr::slice_max\ndplyr::slice_min\ndplyr::slice_tail\nreadr::read_csv\nreadr::read_lines\nreadr::read_rds\nreadr::write_csv\nreadr::write_lines\nreadr::write_rds\nreadxl::excel_sheets\nreadxl::read_excel\ntibble::tibble\ntibble::tribble"
  },
  {
    "objectID": "reading_writing.html#data-for-this-lesson",
    "href": "reading_writing.html#data-for-this-lesson",
    "title": "4  Importing & exporting",
    "section": "4.1 Data for this lesson",
    "text": "4.1 Data for this lesson\nWe will use the following real datasets in this lesson:\nGlobal populations and CO2 emissions: API_EN.ATM.CO2E…csv: These data were compiled by the World Bank DataBank and provides information on the emissions of greenhouse gases and the populations of countries around the world. Neither the tabular data nor the name of the file were modified from the original version.\nIris: iris.csv and iris.rds: This is Edgar Anderson’s famous data set that provides the measurements of flowers of three species of iris, Iris setosa, I. versicolor, and I. virginica. See ?iris for more information (or the original paper at this link!).\nPortal rodents: portal.csv and portal.xlsx. These datasets provide measurements taken in a long term study (the Portal project) on rodent traits in Portal, Arizona. The provided data were collected in a fixed grid established in 1977 and include when an individual was measured, where the measurement occurred, the sex and species of the individual, and their hindfoot length. You can read more about this study and the data they collected at this link. I intentionally made the data a good bit messier than the original version."
  },
  {
    "objectID": "reading_writing.html#set-up-your-session",
    "href": "reading_writing.html#set-up-your-session",
    "title": "3  Reading/writing data",
    "section": "3.2 Set up your session",
    "text": "3.2 Set up your session\nAn R Studio session represents the time spent and operations conducted since opening R (Note: sessions may be saved and loaded to avoid lost work). At the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\n\nIf there are any script files open in your source pane. Close them. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "reading_writing.html#why-work-in-a-project",
    "href": "reading_writing.html#why-work-in-a-project",
    "title": "4  Importing & exporting",
    "section": "4.2 Why work in a project?",
    "text": "4.2 Why work in a project?\nWe will do all of our reading, exploring, and writing data from inside of an RStudio project. Projects have many benefits – probably the largest of them is that all paths to data and code are supplied relative to your project folder.\nFor example, I am working in a project called data_sci. The path to my data_sci folder (the parent folder of my project) is:\n/Volumes/ssd980/gits/datasci_2023/data_sci\nThis project contains a subfolder called data and in that folder is a subfolder called raw. The full path to the folder raw is therefore:\n/Volumes/ssd980/gits/datasci_2023/data_sci/data/raw\nNote: The folder data may also be considered a “child” of its parent folder, data_sci. Likewise, the folder raw is a child of its parent folder, data.\nThe raw data folder contains a .csv file called portal.csv. The full path to this file is:\n/Volumes/ssd980/gits/datasci_2023/data_sci/data/raw/portal.csv\nReading data with a full file path is super cumbersome (Do not run!):\n\nread_csv(\"/Volumes/ssd980/gits/datasci_2023/data_sci/data/raw/portal.csv\")\n\nThe above has two problems:\n\nIf we share our code with others or change our folder structure, the file path will need to be modified\nThat”s a lot of writing for each file that we read in!\n\nWhen we work within a project, the folder that contains the .Rproj file is the working directory for the project. The path to our files within the working directory is written as a relative file path. A relative file path is the path to a file relative to the working directory. Given that my working directory is the folder data_sci, the reading operation above would be written as:\n\nread_csv(\"data/raw/portal.csv\")\n\nIn Base R, we can set our working directory using the function setwd(). Before RStudio came along, this function was on the top of most of our scripts. It might have look something like (Do not run!):\n\n# My code for the tutorial: reading, exploring, and writing data\n\n# setup --------------------------------------------------------\n\nlibrary(tidyverse)\n\n# Set working directory:\n\nsetwd(\"/Volumes/ssd980/gits/datasci_2023/data_sci\")\n\n# Read in portal data:\n\nread_csv(\"data/raw/portal.csv\")\n\nThis certainly helps reduce the amount of writing required to read in files. However …\n\n  Never use setwd()!\nUsing setwd() in your code is dangerous because shared code will never work out-of-the-box. You will have to communicate to others (and your future self) to modify their working directory to match the location on their file systems. Conversely, if you share a project with your collaborators, everything will already be in place for them to execute the code.\nEven more importantly, you might change your mind about where you want to put your code or files. If you move your files to a new location, your code will no longer run until you modify the path within the setwd() function. Your code will be “broken”. When you use projects, you can move your project anywhere you want in your file system and R will still be able to find your files."
  },
  {
    "objectID": "reading_writing.html#reading-data",
    "href": "reading_writing.html#reading-data",
    "title": "4  Importing & exporting",
    "section": "4.3 Reading data",
    "text": "4.3 Reading data\nWe covered this topic in our video “Reading data”, so this section will serve as a review of the key concepts covered and functions used in that video.\n\n4.3.1 Read csv files\nTabular data are most often stored as comma separated values (.csv files). This is a robust format because it does not contain hidden encoding that can sometimes lead to problems (see Excel, below).\nIt is best to read in .csv files with the readr function read_csv():\n\nread_csv(\"data/raw/iris.csv\")\n\nWhen tabular data are read in using read_csv(), the data are arranged into a tibble data frame. Additional information about the reading process (i.e., conversion of raw data to a tibble) are printed and may provide clues to potential problems.\nConversely, when data read in using the base R function read.csv(), no additional information is printed and the data are arranged into a standard data frame (Note: I chose not to run this because it would have taken up a lot of tutorial real estate!):\n\nread.csv(\"data/raw/iris.csv\")\n\n\n   Do not use read.csv()!\nWhenever you use read.csv(), additional exploration steps are necessary to search for errors in your data (see Data exploration, below). It is best to be avoided.\n\n\n\n4.3.1.1 Sometimes reading a csv file is not as easy as it should be …\nWhile encoding is not a problem with .csv files, there are often issues with the data that mess up the reading process. For example, the table below represents raw data that I obtained from the World Bank website:\n\nread_csv(\"data/raw/API_EN.ATM.CO2E.PC_DS2_en_csv_v2_2764620.csv\")\n\nHere, we can see that a weird column name was added to the data – a missing column name was replaced with the unhelpful column name ...3 (see ## New names). Looking at the data in the tibble above, we can see the source of the problem. It seems that the character values associated with what should have been the column names were printed on the second row of the data frame. This suggests that the top rows of the tabular data contained information that should not be a part of the data frame.\nAdditional arguments can be passed to read_csv() to address this problem (and others; see ?read_csv):\n\nread_csv(\n  \"data/raw/API_EN.ATM.CO2E.PC_DS2_en_csv_v2_2764620.csv\", \n  skip = 4, \n  skip_empty_rows = FALSE)\n\n\n   Read the help files!\nWhenever you use a function for the first time, or use a function to address a new application, it is a best practice to read the help file for that function (e.g., ?read_lines). Because functions may change over time, it is also worthwhile to revisit their help files on occasion.\n\n\n Explore read_csv()\nUsing the file above, explore other options for reading in the file with read_csv(). Did we have to use the arguments skip = 4 and skip_empty_rows = FALSE? What could you have done instead?\n\n\n\n\n4.3.2 Read RDS files\nBy far the most straightforward of the file types to read in is the RDS file (but see the caveat associated with these files in “Writing data”, below). RDS files are data sets that are written in, and written for, program R.\nWe can read in an RDS file with the function read_rds():\n\nread_rds(\"data/raw/iris.rds\")\n\nNotice in the above that the first column, species, was read in as a factor. That”s because an RDS file will read in the data with the class and type in which they were written.\nLikewise, an RDS file will maintain all attributes associated with a file:\n\nread_rds(\"data/raw/four_instruments.rds\")\n\nThe character vector above was provided with a names attribute. Those names were maintained when the data were written as an RDS and when the RDS was read back into R.\n\n\n4.3.3 Read Excel files\nExcel files can be challenging to read into R but luckily the package readxl has made the process fairly straightforward.\nThe readxl package is part of the tidyverse, but it is not one of the core packages. As such, we have a choice – we can load the library at the top of our script (i.e., library(readxl)) or call functions from the package directly (e.g., readxl::read_excel). The double colon operator, :: is used to access variables in a package. I prefer to use :: when I only use functions from a package only once or twice in a given script and choose library([package]) if I use the package often.\nEach table in an Excel file is typically stored within worksheets (the tabs on the bottom of the Excel window). Before we read in an Excel file, we should check how many worksheets are present. To do so, we use the function readxl::excel_sheets():\n\nreadxl::excel_sheets(\"data/raw/portal.xlsx\")\n\nThe above returned an atomic character vector with two values, where each value represents the name of a worksheet in the file portal.xlsx.\nBy default, the function readxl::read_excel() will read in only the first worksheet in the file:\n\nreadxl::read_excel(\"data/raw/portal.xlsx\")\n\nIf we would like to read in a different worksheet, we can supply the argument sheet = [name of sheet] (Note: See ?readxl::read_excel):\n\nreadxl::read_excel(\"data/raw/portal.xlsx\", sheet = \"site_7\")\n\nIn the above, we notice that there are quite a few bad column names and what is most likely the correct column names are printed on the fourth line of data. We can add a skip = [number of rows] argument to skip the first few rows of data:\n\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\", \n  sheet = \"site_7\",\n  skip = 4)\n\nNotice in the above that the column Date collected probably should contain a vector of dates but instead it is a character vector, where each value is a set of numbers. That”s because Excel uses a bunch of encoding to generate dates and stores date values in a different format than is presented on the screen.\nWe can specify the types of columns present by providing a character vector of column types.We do this with the col_types argument:\n\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\", \n  sheet = \"site_7\",\n  skip = 4,\n  col_types = \n    c(\"text\",\n      \"date\", \n      \"text\",\n      \"text\",\n      \"numeric\"))\n\nThe above returned a warning message that there was a parsing issue in cells B35 and B36 – neither value could be converted into a date. That”s because the author of the spreadsheet (which was actually me here, just to exhibit an all-too-common problem) used the cells to record metadata.\nThe most straightforward way to address this is to read in only the range of cells that we are interested in. Excel columns are assigned to uppercase letters, the first column we read in, Plot, is “A” and the last column (counting from the left), Weight, is “E”. Excel rows are assigned to numbers. Based on our warning message, we know that our data end on line 34. Because we skipped the first four rows of data, we know that our column names are listed on line 5. Based on this information we can specify the range of cells to read in as:\n\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\", \n  sheet = \"site_7\",\n  range = \"A5:E34\",\n  col_types = \n    c(\"text\",\n      \"date\", \n      \"text\",\n      \"text\",\n      \"numeric\"))\n\nWe can also specify the column names directly. To do so, we read in only the cells that contain data (thus skip the cells that contain column names) and specify our own character vector of column names:\n\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\",\n  sheet = \"site_7\",\n  range = \"A6:E34\",\n  col_names = \n    c(\"plot\",\n      \"date\", \n      \"family\",\n      \"species\", \n      \"weight\"),\n  col_types = \n    c(\"text\",\n      \"date\", \n      \"text\",\n      \"text\",\n      \"numeric\"))"
  },
  {
    "objectID": "reading_writing.html#assignment",
    "href": "reading_writing.html#assignment",
    "title": "4  Importing & exporting",
    "section": "4.5 Assignment",
    "text": "4.5 Assignment\nWe covered assignments in some depth during the preliminary lessons. Recall that assignment, when used as a verb, refers to the process of assigning a reference (also called a name, key, binding, or assignment) to your global environment. R can use this reference to retrieve an object located within your computer’s memory.\nAs it relates to reading in data, assignment allows you to work with the files once you”ve read them in. Let”s read in three of our files of interest and assign names for those objects to the global environment:\n\n# Assign names to the global environment:\n\nfour_instruments &lt;- \n  read_lines(\"data/raw/four_instruments.txt\")\n\niris &lt;- \n  read_rds(\"data/raw/iris.rds\")\n\nportal_observations &lt;- \n  readxl::read_excel(\"data/raw/portal.xlsx\")\n\nTo see whether this worked, we can list the names assigned to our global environment with the function ls():\n\nls()\n\n[1] \"four_instruments\"    \"has_annotations\"     \"iris\"               \n[4] \"portal_observations\"\n\n\nNote: While ls() is often used programmatically, the above should be written in the console pane because we simply used it to look at our assigned names. No future code in your script will be dependent on this execution.\n\n   Follow best practices for assignments!\nThere are few “best practices” to consider when assigning names to the global environment:\n\nUse the &lt;- assignment operator whenever assigning a name to the global environment. Reserve the use of = to assignments within objects (e.g., c(roger = vocals)).\nWhen the subject of an assignment is generated with a function, place the assigned name and function on separate lines.\nAll global assignments should be written in the source pane.\nDo not assign the same name to multiple objects (including modified versions of an original object)\n\n\n\n4.5.1 Garbage collection\nIf an object does not contain a name, it is not saved in your computer’s memory. For example, in the code below the data associated with four_instruments.rds are read into memory just long enough to print the object, but are not stored in our computers’ memory:\n\nread_rds(\"data/raw/four_instruments.rds\")\n\n   roger     pete     john    keith \n\"vocals\" \"guitar\"   \"bass\"  \"drums\" \n\n\nWe can also remove a name assigned to our global environment. When we do so, the our computer will no longer maintain that file in our computer’s memory. This process is known as garbage collection.\nWe can remove assignments from the global environment with the function rm():\n\nrm(portal_observations)\n\n\n Use rm() from within your script file!\nRemoving a name from your global environment can have downstream effects (i.e., impact code run later in a script). If rm() removes a name that was assigned to your global environment in your script file, avoid conducting this operation in the console pane.\n\nWe can check if this worked by listing the names assigned to our global environment with ls():\n\nls()\n\n[1] \"four_instruments\" \"has_annotations\"  \"iris\"            \n\n\nIf we want to remove multiple assignments at the same time, we separate the names of each assignment with a comma:\n\nrm(four_instruments, iris)\n\nls()\n\n[1] \"has_annotations\"\n\n\nBecause the function ls() generates a character vector of assigned names, placing the function inside of rm() will remove all names assigned to the global environment. This is the second argument of the rm function, so we must specify the name of the argument in the function call (see ?rm):\n\n# Assign names to the global environment:\n\nfour_instruments &lt;- \n  read_lines(\"data/raw/four_instruments.txt\")\n\niris &lt;- \n  read_rds(\"data/raw/iris.rds\")\n\nportal_observations &lt;- \n  readxl::read_excel(\"data/raw/portal.xlsx\")\n\nrm(\n  list = ls())\n\nls()\n\ncharacter(0)\n\n\nNotice in the above, that the function ls() is nested inside of rm(). R executes the nested function prior to the function it is nested within.\n\n Assign four_instruments and iris to your global environment\nWe will be using four_instruments.txt and iris.rds in a later part of this lesson. Please read in the files and assign their names to your global environment.\n\n\n   Manage your global environment!\nMemory is very costly, especially when our data are large. As assigned names represent objects stored in our memory, maintaining objects that we don”t need can slow down processing or even lead to aborted R sessions. Likewise, our global environment will often get cluttered with object names that we no longer need. This can generate a disorganized workflow. The utility of the Environment tab of the Environment pane is diminished if our environment contains loads of assignments. For both of these reasons, it is very important to remove unused assignments from our global environment."
  },
  {
    "objectID": "reading_writing.html#data-from-scratch",
    "href": "reading_writing.html#data-from-scratch",
    "title": "4  Importing & exporting",
    "section": "4.6 Data from scratch",
    "text": "4.6 Data from scratch\nIt is often useful to create your own data sets. I do so frequently to provide a basis for testing how a function works, running a simulation, or iteration (coming soon!).\n\n4.6.1 Atomic vectors\nAn atomic vector is a one-dimensional object where each value is of the same class. We can generate an atomic vector using the combine function, c():\n\n# A vector of musicians for each instrument:\n\nc(\"roger\",\n  \"pete\",\n  \"john\",\n  \"keith\")\n\n[1] \"roger\" \"pete\"  \"john\"  \"keith\"\n\n# A vector of integers:\n\n1:4\n\n[1] 1 2 3 4\n\n# A vector of double numeric values:\n\nc(1, 2, 3, 4)\n\n[1] 1 2 3 4\n\n\nWe can maintain the vector in our global environment through assignment:\n\nmusicians &lt;-\n  c(\"roger\",\n    \"pete\",\n    \"john\",\n    \"keith\")\n\nNotice what happens when we use c() to combine two vectors of different classes:\n\nc(four_instruments, 1:4)\n\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\"  \"1\"      \"2\"      \"3\"      \"4\"     \n\n\nBecause c() generates an atomic vector and all values in an atomic vector must be of the same class, the integer values were changed to characters. Knowing this can help find problems in a data set. For example, if you read in a dataset and there is a column that you believe should be numeric but has been converted to a character, it is likely that there is a character value hidden somewhere in the data.\n\n\n4.6.2 Lists\nAn atomic vector is, in a way, a restrictive type of list. A list is a one-dimensional object where values, which here are called list items, can be of any class.\nWe can generate a list with the list() function. Watch what happens when we combine four_instruments and 1:4 into a list:\n\nlist(four_instruments, 1:4)\n\n[[1]]\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\" \n\n[[2]]\n[1] 1 2 3 4\n\n\nThe classes were maintained because lists do not have to be atomic.\nAdditionally, a list item does not have to be a single value – it can be any object:\n\nlist(musicians, four_instruments)\n\n[[1]]\n[1] \"roger\" \"pete\"  \"john\"  \"keith\"\n\n[[2]]\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\" \n\n\nNotice that the list items are not named with the list function by default. We can view this by nesting list() inside of the names() function.\n\nnames(\n  list(musicians, four_instruments))\n\nNULL\n\n\nNames can be assigned to each item using the internal assignment operator (=). In the below, I store the list in memory by assigning the name my_list to the object, and assign names to each list item with the = assignment operator:\n\nnames(\n  list(\n    musicians = musicians,\n    four_instruments = four_instruments))\n\n[1] \"musicians\"        \"four_instruments\"\n\n\nBy naming the list items, I can extract the values associated with a name using the $ operator:\n\nlist(\n    musicians = musicians,\n    four_instruments = four_instruments)$four_instruments\n\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\" \n\n\nAn alternative to list() is the tidyverse function tibble::lst(). This function can be used to generate a list and maintain the names that were globally assigned to the child objects. The package tibble is part of the core tidyverse so, with tidyverse loaded you can call the function directly:\n\nlst(musicians, four_instruments)\n\n$musicians\n[1] \"roger\" \"pete\"  \"john\"  \"keith\"\n\n$four_instruments\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\" \n\nnames(\n  lst(musicians, four_instruments))\n\n[1] \"musicians\"        \"four_instruments\"\n\nlst(musicians, four_instruments)$four_instruments\n\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\" \n\n\n\n   Restrictions are annoying great!\nThe flexibility of lists makes them very powerful … unfortunately it also can make them difficult to work with and prone to errors. Restrictions in the behavior of objects makes it much easier to spot problems in our data.\n\n\n\n4.6.3 Tibbles\nA data frame is a special type of list. Data frames have two important restrictions that distinguish them from other types of lists:\n\nEach column in a data frame is a list item of equivalent length.\nThe data that comprise a column must be of the same class.\n\nWe can use the function data.frame() to combine two vectors into a single data object:\n\nmy_df &lt;- \n  data.frame(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\"),\n    role = four_instruments)\n\nmy_df\n\n  musician   role\n1    roger vocals\n2     pete guitar\n3     john   bass\n4    keith  drums\n\n\nTibbles are a special kind of data frame. In this course, we will use tibbles more than any other kind of data object.\nTo generate a tibble data frame, we can use the function tibble() to combine two vectors into a single data object:\n\n# A tibble of musicians and their instruments:\n\nmy_tibble &lt;- \n  tibble(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\"),\n    role = four_instruments)\n\nmy_tibble\n\n# A tibble: 4 × 2\n  musician role  \n  &lt;chr&gt;    &lt;chr&gt; \n1 roger    vocals\n2 pete     guitar\n3 john     bass  \n4 keith    drums \n\n\nIt is pretty obvious that tibbles are printed differently than data frames. The differences don”t stop there though – they are also more restrictive.\nFor example, notice the kind of object that is returned when we use indexing to extract the second column in a data frame:\n\nmy_df[, 2]\n\n[1] \"vocals\" \"guitar\" \"bass\"   \"drums\" \n\n\nIt is an atomic vector! For a tibble, the class of object does not change (it is still a tibble):\n\nmy_tibble[, 2]\n\n# A tibble: 4 × 1\n  role  \n  &lt;chr&gt; \n1 vocals\n2 guitar\n3 bass  \n4 drums \n\n\nTibbles are also restrictive about the use of $. In a data frame, columns can be extracted with partial matching:\n\nmy_df$musician\n\n[1] \"roger\" \"pete\"  \"john\"  \"keith\"\n\nmy_df$m\n\n[1] \"roger\" \"pete\"  \"john\"  \"keith\"\n\n\nIn a tibble, partial matching is not allowed:\n\nmy_tibble$musician\n\n[1] \"roger\" \"pete\"  \"john\"  \"keith\"\n\nmy_tibble$m\n\nWarning: Unknown or uninitialised column: `m`.\n\n\nNULL\n\n\nFinally (though there are more differences), data frames will recycle values during their construction:\n\ndata.frame(\n  a = 1, \n  b = 1:4)\n\n  a b\n1 1 1\n2 1 2\n3 1 3\n4 1 4\n\ndata.frame(\n  a = 1:2, \n  b = 1:4)\n\n  a b\n1 1 1\n2 2 2\n3 1 3\n4 2 4\n\n\nWhereas tibbles will only recycle a single value:\n\ntibble(\n  a = 1, \n  b = 1:4)\n\n# A tibble: 4 × 2\n      a     b\n  &lt;dbl&gt; &lt;int&gt;\n1     1     1\n2     1     2\n3     1     3\n4     1     4\n\ntibble(\n  a = 1:2,\n  b = 1:4)\n\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n• Size 2: Existing data.\n• Size 4: Column `b`.\nℹ Only values of size one are recycled.\n\n\n\n   Ugh … an error message!\nError messages are annoying but incredibly useful – we need to find a place in our hearts to appreciate them. With restrictions on a function”s usage or on the structure and composition of a data object, error messages stop us from making mistakes. When we generate an error message, it generally means that there is something that we don”t understand about the data that we are using or the function that”s throwing the error.\n\n\n4.6.3.1 Other ways of generating tibbles …\nWe can also construct a tibble by binding the vectors together with the bind_cols() function:\n\n# A tibble of musicians and their instruments:\n\nbind_cols(\n  musician = \n    c(\"roger\",\n      \"pete\",\n      \"john\",\n      \"keith\"),\n  role = four_instruments)\n\n# A tibble: 4 × 2\n  musician role  \n  &lt;chr&gt;    &lt;chr&gt; \n1 roger    vocals\n2 pete     guitar\n3 john     bass  \n4 keith    drums \n\n\nBecause a tibble is a list and each column is a list item, we can also use bind_cols to combine two tibbles (by column):\n\n# A tibble of musicians and their instruments:\n\nbind_cols(\n  tibble(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\")),\n  tibble(\n    role = four_instruments))\n\n# A tibble: 4 × 2\n  musician role  \n  &lt;chr&gt;    &lt;chr&gt; \n1 roger    vocals\n2 pete     guitar\n3 john     bass  \n4 keith    drums \n\n\nFinally, it is often useful to use the tribble() function to generate a tibble. This allows for row-wise tibble construction – in other words, the tribble() function allows us to generate a tibble with code that looks like the output. To do so, column names are preceded by a function operator (~) and separated by a comma. Values are typically written in the position that they will occupy in the resultant tibble.\n\n# Combining the two vectors into a tibble with tribble():\n\ntribble(\n  ~ musician, ~ role,\n  \"roger\",  \"vocals\",\n  \"pete\",   \"guitar\",\n  \"john\",   \"bass\",\n  \"keith\",  \"drums\")\n\n# A tibble: 4 × 2\n  musician role  \n  &lt;chr&gt;    &lt;chr&gt; \n1 roger    vocals\n2 pete     guitar\n3 john     bass  \n4 keith    drums"
  },
  {
    "objectID": "reading_writing.html#data-exploration",
    "href": "reading_writing.html#data-exploration",
    "title": "4  Importing & exporting",
    "section": "4.4 Data exploration",
    "text": "4.4 Data exploration\nWhenever we read in data, it is crucial to take the time to explore its class, structure, composition, and the distribution of values.\nIf we read in a non-tibble data frame, we should be sure to explore the structure with the function pillar::glimpse(). The package pillar is part of the core tidyverse so, with tidyverse loaded you simply need to supply the name of the function and the data frame that you would like to explore:\n\nglimpse(my_df)\n\nIn the above, we see the number of observations (rows) and number of variables (columns). We are also given information on the name and class of each column and the first few values in each.\nIn a tibble data frame, this information is printed by default:\n\nmy_tibble\n\nDespite this handy printing of the tibble, we often need to use the number of rows or columns in a data frame programmatically.\nWe can determine the number of rows with nrow():\n\nnrow(my_tibble)\n\nAnd determine the number of columns with ncol():\n\nncol(my_tibble)\n\nNote that because a data frame is a list, and each column represents a list item, the function length() will return the number of columns:\n\nlength(my_tibble)\n\nWe can return the number of rows and columns at the same time using the function dim():\n\ndim(my_tibble)\n\nThis returned an integer vector of dimensions in the rows (the first number) and columns (the second number).\nIf you”ve got too many functions swimming around in your brain, it is worth noting that you can use the function dim() and indexing to get the number of rows in the data frame:\n\ndim(my_tibble)[[1]]\n\n… or the number of columns:\n\ndim(my_tibble)[[2]]\n\n\n4.4.1 Heads and tails\nThe dplyr package, part of the tidyverse core, contains a set of functions that start with the prefix slice_ that allows you to print a subset of the data (see ?slice).\nWe can print the top row of a data frame using the function slice_head():\n\nslice_head(iris)\n\n… or print the bottom row of a data frame using the function slice_tail():\n\nslice_tail(iris)\n\nWith the argument n = [number of rows], we can subset to the number of rows of our choosing. For example, to view just the first two rows of the data frame, we can use:\n\nslice_head(iris, n = 2)\n\nWe can also subset to a proportion of rows with the argument prop = [proportion of rows]. For example, to subset the data to just the last 5 percent of rows we would write:\n\nslice_tail(iris, prop = 0.05)\n\nWe can even slice the data to the row associated with maximum value of a variable:\n\nslice_max(iris, order_by = sepal_length)\n\n… or the minimum value of a variable:\n\nslice_min(iris, order_by = sepal_length)\n\n… or even the 5 rows with that contain the smallest values of a variable:\n\nslice_min(\n  iris, \n  n = 5,\n  order_by = sepal_length)\n\n\n\n4.4.2 Ordering\nYou may have noticed when we ran slice_min() and slice_max() that the tibbles were ordered by the values in the specified columns (thus order_by =). Ordering a data frame is a great way to explore the values therein and look for potential problems.\nWe can order an entire table by a variable”s value using arrange():\n\narrange(iris, sepal_length)\n\nThis arranged the table from shortest to longest sepal length values. If we want to order the table from the largest to smallest sepal lengths, we nest the function desc() inside of the arrange function:\n\narrange(\n  iris, \n  desc(sepal_length))\n\nFor character values, arrange() will sort the table alphabetically:\n\narrange(\n  my_tibble,\n  role)\n\n\narrange(\n  my_tibble,\n  desc(role))\n\n\n\n4.4.3 Characters and factors\nIt is often necessary to know the unique values present in a set of characters or factors.\nIf a column is a character of factor vector, we can determine the unique values using, appropriately, the function unique():\n\nunique(iris$species)\n\nThis returned a character vector that only contained the unique values in iris$species.\nIf the column is a factor, this information can also be extracted using the function levels():\n\nlevels(iris$species)\n\nIf we want to see the number of records associated with a unique character value, we can use the function table():\n\ntable(iris$species)\n\nThe variable iris$species is a factor, but this also works on a character vector:\n\ntable(\n  as.character(iris$species))\n\nIn the above, we are given a very handy printout of the distribution of the data.\n\n\n4.4.4 Statistical summaries\nWhen reading in data, it is often useful to look at the summary statistics for the dataset. This can help you find any errors (e.g., potential outliers or NA values). To do so, a good place to start is the function summary():\n\nsummary(iris)\n\nNote: But see what happens when you run summary(my_tibble) … the printed summary information for character values isn”t particularly useful!\nYou can also look at summary statistics individually. This can be especially useful programmatically. I won”t bore you with a lot of text to describe each one, but here”s a few to try on your own (see ?[function_name] if you have any questions about what each does!):\n\nmin(iris$sepal_length)\n\nmax(iris$sepal_length)\n\nmean(iris$sepal_length)\n\nmedian(iris$sepal_length)\n\nvar(iris$sepal_length)\n\nsd(iris$sepal_length)\n\n\n\n4.4.5 A bad habit\nThere is one early exploration step that is commonly used that I do not recommend … the function view(). This function allows you to view your data as though it were a spreadsheet. Here”s how it is applied (I have not run it here, but you may run it on your own).\n\nview(iris)\n\nInvariably, you”re going to use this function anyways and when I see you do it during our help sessions I will invariably complain – I might even emit a high-pitched whiny squeel. The student response to my whining is usually something like “… but I like to see my data.”\nHere”s the deal: You get very little information by looking directly at the data. There is no indication of column classes, no indication of the number of rows (without scrolling), it is nearly impossible to spot bad character or factor values, and there is little opportunity to explore numeric values (other than ordering). When the data get large, any utility of this tool quickly falls away. It is better to get in the practice of properly exploring the data. As such …\n\n   For God”s sake, don”t use view()!"
  },
  {
    "objectID": "reading_writing.html#writing-data",
    "href": "reading_writing.html#writing-data",
    "title": "4  Importing & exporting",
    "section": "4.5 Writing data",
    "text": "4.5 Writing data\nOur final topic of this section is how to write data to a file. This is quite straightforward, so this section will (actually) be brief for once. To reduce clutter in your data folder, we will remove each file after writing.\n\n4.5.1 Atomic vectors\nThere are two preferred ways to write an atomic vector to a file: as a .txt file or as an .RDS file.\nIf you intend to share your vector outside of program R, saving the vector as a text file is a great way to do it. To do so, use the write_lines() function. The first argument of the function is the data to write and the second argument is the relative file path:\n\nwrite_lines(four_instruments, file = \"data/raw/temp.txt\")\n\nWe can use the list.files() function to see if the file was written:\n\nlist.files(\"data/raw\", pattern = \"txt\")\n\n… and really check to see if it worked by reading the data back in:\n\nread_lines(\"data/raw/temp.txt\")\n\nWe will remove this file with file.remove():\n\nfile.remove(\"data/raw/temp.txt\")\n\n… and check to see if we successfully removed the file:\n\nlist.files(\"data/raw\", pattern = \"txt\")\n\nIf you do not intend to use or share the data outside of R, your best bet is to save the data as an .RDS file. For this, we use the function write_rds(). Again, the first argument of the function is the data to write and the second argument is the relative file path:\n\n# Write four instruments to file:\n\nwrite_rds(four_instruments, file = \"data/raw/temp.rds\")\n\n# Did it work?\n\nread_rds(\"data/raw/temp.rds\")\n\n# Yup, remove it!\n\nfile.remove(\"data/raw/temp.rds\")\n\n\n   When should I write a file as an RDS?\nReading and writing .RDS files is super straightforward in R. As stated previously, you maintain all of the attributes of the data and, frankly, little thought has to be given about the structure of the object. If you”re happy with it is current structure, you”re good to go. That being said, do not write the file as an .RDS if:\n\nYou intend to share the file with a non-R-user\nYou plan to work with the file outside of R (hopefully, that won”t be the case)\nThe file is too big to fit in your memory (in such cases, R only maintains a pointer to a temporary file stored on your hard drive)\n\n\n\n\n4.5.2 Lists\nThe only way that I save lists is as an .RDS file! Let”s make a list:\n\nmy_list &lt;-\n  list(\n    band = my_tibble,\n    instruments = four_instruments)\n\n… save it as an .RDS file:\n\nwrite_rds(my_list, \"data/raw/temp.rds\")\n\n… check to see if it worked:\n\nread_rds(\"data/raw/temp.rds\")\n\n… and remove the file:\n\nfile.remove(\"data/raw/temp.rds\")\n\nI should note that you can use R to write a list as an Excel file (each list item is written to a separate worksheet). I do not recommend doing so, but the package xlsx has tools to accomplish this inadvisable task!\n\n\n4.5.3 Data frames\nThe last kind of data We will write is a tibble. There are three options for doing so:\n\nwrite.csv: Base R version (do not use!)\nwrite_csv: readr version (use this!)\nwrite_rds: As above, handy if you don”t intend to share the file with a non-R-user!\n\nLet”s start with write.csv(). Again, we supply the dataset and a path to the file:\n\nwrite.csv(my_tibble, file = \"data/raw/temp.csv\")\n\n… let”s see what the above returned:\n\nread_csv(\"data/raw/temp.csv\")\n\nWe can see that this returned an additional column with (rarely useful) row numbers! We can modify this with an argument (row.names = FALSE), but there”s a better way …\nUse write_csv():\n\nwrite_csv(my_tibble, file = \"data/raw/temp.csv\")\n\n… see what the above returned:\n\nread_csv(\"data/raw/temp.csv\")\n\nIt is great! Let”s delete the file:\n\nfile.remove(\"data/raw/temp.csv\")\n\nAs above, we could have also written the file using write_rds() (but see caveats):\n\n# Write as an rds file:\n\nwrite_rds(my_tibble, \"data/raw/temp.rds\")\n\n# Check to see if it worked:\n\nread_rds(\"data/raw/temp.rds\")\n\n# Remove the file:\n\nfile.remove(\"data/raw/temp.rds\")\n\n\n\n4.5.4 A final note\nIt is important to consider when a file should be written to your hard drive. Despite the number of files We will use in this course, I write files very rarely. Instead, once I get a raw data file, I generate a script for pre-processing the data and various wrangling steps. Rather than save the processed data, I save and run the script that executes the data processing. The only exception to this is when I work with very large files – files for which the pre-processing script takes a long time to execute (&gt; 30 seconds or so). Using this method helps avoid storing multiple versions of the same file and thus improves your organization and workflow."
  },
  {
    "objectID": "reading_writing.html#set-up-your-script",
    "href": "reading_writing.html#set-up-your-script",
    "title": "3  Reading/writing data",
    "section": "3.3 Set up your script",
    "text": "3.3 Set up your script\n\nCreate a script file (Windows: Ctrl + Shift + N; Mac: Cmd + Shift + N)\nAdd metadata (e.g., # My code for the tutorial: reading, exploring, and writing data)\nFollowing your metadata, create a new code section (Windows: Ctrl + Shift + R; Mac: Cmd + Shift + R) and call it “setup” (Note: A code section is a portion of a script file that is delineated by a section header)\nFollowing your section header, load the tidyverse library (library(tidyverse))\n\nAt this point, your script should look something like:\n\n# My code for the tutorial: reading, exploring, and writing data\n\n# setup --------------------------------------------------------\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "reading_writing.html#before-you-begin",
    "href": "reading_writing.html#before-you-begin",
    "title": "4  Importing & exporting",
    "section": "4.2 Before you begin",
    "text": "4.2 Before you begin\nPlease ensure that you are working in a\n\nCreate a script file (Windows: Ctrl + Shift + N; Mac: Cmd + Shift + N)\nAdd metadata (e.g., # My code for the tutorial: reading, exploring, and writing data)\nFollowing your metadata, create a new code section (Windows: Ctrl + Shift + R; Mac: Cmd + Shift + R) and call it “setup” (Note: A code section is a portion of a script file that is delineated by a section header)\nFollowing your section header, load the tidyverse library (library(tidyverse))\n\nAt this point, your script should look something like:\n\n# My code for the tutorial: reading, exploring, and writing data\n\n# setup --------------------------------------------------------\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "getting_started.html#preliminary-course-content",
    "href": "getting_started.html#preliminary-course-content",
    "title": "1  Getting started",
    "section": "1.1 Preliminary course content",
    "text": "1.1 Preliminary course content\nPrior to starting this module, I strongly suggest completing the preliminary course material. The lessons are designed to assist R beginners in getting a baseline familiarity with key R programming concepts and serve as an important refresher for those already working regularly in R. Even if you’re coming in with loads of R experience, you’ll almost certainly learn a thing or two along the way!\n\nLesson 1: Introduction to R and RStudio\nLesson 2: Values\nLesson 3: Objects\nLesson 4: Indexing"
  },
  {
    "objectID": "getting_started.html#setting-up-a-session",
    "href": "getting_started.html#setting-up-a-session",
    "title": "1  Before you begin",
    "section": "1.2 Setting up a session",
    "text": "1.2 Setting up a session\nAn R Studio session represents the time spent and operations conducted since opening R (Note: sessions may be saved and loaded to avoid lost work). At the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\n\nIf there are any script files open in your source pane. Close them. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "course_introduction.html#your-recipe-for-success",
    "href": "course_introduction.html#your-recipe-for-success",
    "title": "1  Course introduction",
    "section": "1.2 Your recipe for success",
    "text": "1.2 Your recipe for success\nThis course is, to put it mildly, challenging. If you have a solid strategy for working through the content, however, you will emerge from this experience with an incredible skillset that is ready to take on even the toughest of data challenges.\nThrough my experiences with students throughout the years, I’ve found that the following practices are typically followed by students who get the most out of this course:\n\nView all content in the order that it is presented: We are often drawn to content that relates to something we would like to learn. Because each lesson builds on the previous lessons, it is important to avoid the temptation of exploring the content out of order.\nDo not skip lessons: It is often easy to say to yourself “I already know how to do that” and, as such, either skip a given lesson or pay less attention to that lesson. Each lesson likely includes new functions, new function arguments, or important details that you may miss with even the most familiar of functions.\nCode along with all content: It is super important that you play an active role with each of the coding elements of this course. Avoid simply viewing or reading a given lesson – passive learning will not get you very far in this course.\nAttempt all of the “Now you!” challenges before I reveal the answers: There are several points in the lessons in which I have you solve a problem to self-assess your progress. I call these “Now you!” challenges. Working through these challenges will help you determine what you are currently missing in your understanding of the content. They also often inform the questions that I ask during the weekly (and final) problem sets!\nRead the help files for every function: Although this can be time consuming, reading the help files will help you get a handle on what a given function can (and cannot) do. Because the arguments of a function often change over time, and because functions are sometimes deprecated, taking the time to read even the functions that you are super familiar with is important!\nVisit, ask questions on, comment, and read the course discussion board often: I will say it a lot, but the course discussion board is the most important learning tool in this course!\nGenerate your own function schema: I will provide you with an organizational system that I use to remember which functions to apply to given tasks. I call this a “function schema” and mine acts a lot like a dichotomous key (likely because I learned how to ID plants and fungi well before I learned how to code). Because we all use different methods for grouping items in our brains, I recommend coming up with your own organizational system, sharing that system with your peers, and modifying your schema along the way.\nKeep a paper notebook on your computer desk: Keeping notes will help you keep track of what you are learning and prepare you to get the most out of the live course sessions (Question & Answer and Review). As you go through the content, be sure to write down anything that you are not clear on. The process of transforming code language into prose is also very helpful!\nAfter completing a lesson, annotate your scripts with comments: It\nAsk yourself “what don’t I know?”:\nAvoid Stack Overflow:"
  },
  {
    "objectID": "course_introduction.html#getting-help",
    "href": "course_introduction.html#getting-help",
    "title": "1  Course introduction",
    "section": "1.3 Getting help",
    "text": "1.3 Getting help\nElements of this course may be challenging, but help is on the way!\n\nThe course Discussion board is a great peer-to-peer learning resource and should be your first stop if you are having difficulty!\nR for Data Science (https://r4ds.hadley.nz/) is our primary textbook for this course. Written by the Posit team, this book will help clarify course concepts. I will also post required readings throughout the semester to supplement course materials.\nQuestion & Answer sessions are offered every Friday and are meant to help you with your weekly problem sets.\nWeekly review sessions are offered every Monday. In these sessions we review the problem set key and address any questions that you may have.\nVirtual office hour sessions are offered to provide one-on-one help with course materials.\nPlease contact us via email if you find an error in the content or require assistance with course logistics.\n\nBrian Evans: evansbr@si.edu\nJoe Kolowski: kolowskij@si.edu"
  },
  {
    "objectID": "setup.html#initiating-your-session",
    "href": "setup.html#initiating-your-session",
    "title": "3  Setting up your session",
    "section": "3.1 Initiating your session",
    "text": "3.1 Initiating your session\nAt the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\nClose any script files open in your source pane. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "getting_started.html#preliminary-content",
    "href": "getting_started.html#preliminary-content",
    "title": "1  Getting started",
    "section": "1.1 Preliminary content",
    "text": "1.1 Preliminary content\nPrior to starting this module, I strongly suggest completing the preliminary course material. The lessons are designed to assist R beginners in getting a baseline familiarity with key R programming concepts and serve as an important refresher for those already working regularly in R. Even if you’re coming in with loads of R experience, you’ll almost certainly learn a thing or two along the way!\n\nLesson 1: Introduction to R and RStudio\nLesson 2: Values\nLesson 3: Objects\nLesson 4: Indexing"
  },
  {
    "objectID": "getting_started.html#set-your-global-options",
    "href": "getting_started.html#set-your-global-options",
    "title": "2  Before you begin",
    "section": "2.1 Set your global options",
    "text": "2.1 Set your global options\nRStudio’s global options define the behavior and layout of the RStudio IDE every time you open the program. Here, we will modify your global options to ensure that they are set to maximize your success in this course (and beyond).\nPlease follow the steps in the video below to set up your global options:"
  },
  {
    "objectID": "getting_started.html#set-up-your-session",
    "href": "getting_started.html#set-up-your-session",
    "title": "2  Before you begin",
    "section": "2.2 Set up your session",
    "text": "2.2 Set up your session\nAn R Studio session represents the time spent and operations conducted since opening R.\n\n2.2.1 Open an RStudio project\nA session is initiated by opening a project in RStudio. A project is a folder that contains a collection of files (e.g., scripts, data, output) and sub-folders. The parent folder is designated as a project if it includes a .Rproj file. All content for this course will be stored in a project and all code will be executed from within this project.\nWe can open our project in one of four ways:\nThe project menu ()\n\nNote: If you use this method, you can open a recent project by simply clicking on the name from the list of options at the bottom of the dropdown menu.\n\nOpen RStudio\nClick the blue square in the upper right of the window\nNavigate to “Open Project …”\nNavigate to your project in the window that opens\nDouble-click on the .Rproj file.\n\nThe  file menu\n\n\nOpen RStudio\nIn the top menu bar, click “File”\nNavigate to “Open Project …”\nNavigate to your project in the window that opens\nDouble-click on the .Rproj file.\n\nUsing a keyboard shortcut\n\n\nOpen RStudio\nHit the keyboard shortcut Control + O (Windows) or Command + O (Mac)\nNavigate to your project in the window that opens\nDouble-click on the .Rproj file.\nHit enter on the following pop-up menu.\n\nWindows Explorer () or Finder ()\n\n\nOpen your system’s file explorer (e.g. “Finder” on Macs)\nNavigate to your project in the window that opens\nDouble-click on the .Rproj file.\n\n\n Always work within a project!\nWorking in an RStudio project offers lots of advantages. These include (but are not limited to):\n\nYour project folder is the root directory of files read in by R. In other words, you read in files relative to their location within the project folder.\nProjects ensure that your data and scripts are stored in one, easy-to-find, space.\nThrough sharing projects, rather than individual files, it is easy to generate reproducible scripts.\nProjects provide you with the opportunity to use different versions of packages for various applications.\n\nWe will explore these advantages and more in coming lessons!\n\n\n\n2.2.2 Housekeeping steps\nAt the beginning of each session, I like to do a series of what I call “housekeeping steps”. These include clearing any open scripts, your global environment, and your code history. Doing so helps you better organize your workflow and ensures that you can make the most out of RStudio’s tools for managing your code and data during a session.\nI strongly recommend following the steps below at the start of each session:\n\nIf there are any script files open in your source pane. Close them. Note: If any of your script titles are blue, you might want to save them prior to closing!\n\n\n\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\n\n\n\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand!"
  },
  {
    "objectID": "course_introduction.html#preliminary-content",
    "href": "course_introduction.html#preliminary-content",
    "title": "1  Course introduction",
    "section": "1.1 Preliminary content",
    "text": "1.1 Preliminary content\nPrior to starting this course, I strongly suggest completing the preliminary course material. These lessons contain the core knowledge and skills that I believe an early beginner in R should have obtained. The lessons also contain elements of the language that is often overlooked by those with considerable R experience. Even if you’re coming in with loads of R experience, you’ll almost certainly learn a thing or two along the way!\n\nLesson 1: Introduction to R and RStudio\nLesson 2: Values\nLesson 3: Objects\nLesson 4: Indexing"
  },
  {
    "objectID": "creating_objects.html#initiating-your-session",
    "href": "creating_objects.html#initiating-your-session",
    "title": "3  Creating objects",
    "section": "3.1 Initiating your session",
    "text": "3.1 Initiating your session\nAt the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\nClose any script files open in your source pane. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "dplyr_verbs.html#initiating-your-session",
    "href": "dplyr_verbs.html#initiating-your-session",
    "title": "6  dplyr verbs",
    "section": "6.1 Initiating your session",
    "text": "6.1 Initiating your session\nAt the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\nClose any script files open in your source pane. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "ggplot_intro.html#initiating-your-session",
    "href": "ggplot_intro.html#initiating-your-session",
    "title": "7  Data visualization",
    "section": "7.1 Initiating your session",
    "text": "7.1 Initiating your session\nAt the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\nClose any script files open in your source pane. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "code_formatting.html#initiating-your-session",
    "href": "code_formatting.html#initiating-your-session",
    "title": "8  Best practices",
    "section": "8.1 Initiating your session",
    "text": "8.1 Initiating your session\nAt the beginning of each session, I like to do a series of housekeeping steps. Please do the following before continuing:\n\nOpen your RStudio project. You can do so in one of three ways:\n\nOpen RStudio, click the blue square in the upper right of the window, navigate to the name of your project, and click on the name.\nOpen RStudio and, in the top menu bar, click File, Open Project …, navigate to your project in the window that opens, and hit Enter.\nIn your system’s file explorer (e.g., “finder” in Mac), navigate to the folder where your project is located and click on the file that has the extension “.Rproj”.\n\nClose any script files open in your source pane. Note: If any of your script titles are blue, you might want to save them prior to closing!\nIn the Environment tab of your workspace pane, ensure that your Global Environment is empty. If it is not, click the broom to remove all objects.\nIn the History tab of your workspace pane, ensure that your history is empty. If it is not, click the broom to remove your history.\n\nBy completing the steps above, your current session will be dedicated, in its entirety, to the task at hand. That really helps organize your workflow during a given session.\n\n  Always work from inside of a project!"
  },
  {
    "objectID": "objects_review.html",
    "href": "objects_review.html",
    "title": "3  Objects",
    "section": "",
    "text": "It is often useful to create your own data sets. I do so frequently to provide a basis for testing how a function works, running a simulation, or iteration (coming soon!).\n\n3.0.1 Atomic vectors\nAn atomic vector is a one-dimensional object where each value is of the same class. We can generate an atomic vector using the combine function, c():\n\n# A vector of musicians for each instrument:\n\nc(\"roger\",\n  \"pete\",\n  \"john\",\n  \"keith\")\n\n# A vector of integers:\n\n1:4\n\n# A vector of double numeric values:\n\nc(1, 2, 3, 4)\n\nWe can maintain the vector in our global environment through assignment:\n\nmusicians &lt;-\n  c(\"roger\",\n    \"pete\",\n    \"john\",\n    \"keith\")\n\nNotice what happens when we use c() to combine two vectors of different classes:\n\nc(four_instruments, 1:4)\n\nBecause c() generates an atomic vector and all values in an atomic vector must be of the same class, the integer values were changed to characters. Knowing this can help find problems in a data set. For example, if you read in a dataset and there is a column that you believe should be numeric but has been converted to a character, it is likely that there is a character value hidden somewhere in the data.\n\n\n3.0.2 Lists\nAn atomic vector is, in a way, a restrictive type of list. A list is a one-dimensional object where values, which here are called list items, can be of any class.\nWe can generate a list with the list() function. Watch what happens when we combine four_instruments and 1:4 into a list:\n\nlist(four_instruments, 1:4)\n\nThe classes were maintained because lists do not have to be atomic.\nAdditionally, a list item does not have to be a single value – it can be any object:\n\nlist(musicians, four_instruments)\n\nNotice that the list items are not named with the list function by default. We can view this by nesting list() inside of the names() function.\n\nnames(\n  list(musicians, four_instruments))\n\nNames can be assigned to each item using the internal assignment operator (=). In the below, I store the list in memory by assigning the name my_list to the object, and assign names to each list item with the = assignment operator:\n\nnames(\n  list(\n    musicians = musicians,\n    four_instruments = four_instruments))\n\nBy naming the list items, I can extract the values associated with a name using the $ operator:\n\nlist(\n    musicians = musicians,\n    four_instruments = four_instruments)$four_instruments\n\nAn alternative to list() is the tidyverse function tibble::lst(). This function can be used to generate a list and maintain the names that were globally assigned to the child objects. The package tibble is part of the core tidyverse so, with tidyverse loaded you can call the function directly:\n\nlst(musicians, four_instruments)\n\nnames(\n  lst(musicians, four_instruments))\n\nlst(musicians, four_instruments)$four_instruments\n\n\n   Restrictions are annoying great!\nThe flexibility of lists makes them very powerful … unfortunately it also can make them difficult to work with and prone to errors. Restrictions in the behavior of objects makes it much easier to spot problems in our data.\n\n\n\n3.0.3 Tibbles\nA data frame is a special type of list. Data frames have two important restrictions that distinguish them from other types of lists:\n\nEach column in a data frame is a list item of equivalent length.\nThe data that comprise a column must be of the same class.\n\nWe can use the function data.frame() to combine two vectors into a single data object:\n\nmy_df &lt;- \n  data.frame(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\"),\n    role = four_instruments)\n\nmy_df\n\nTibbles are a special kind of data frame. In this course, we will use tibbles more than any other kind of data object.\nTo generate a tibble data frame, we can use the function tibble() to combine two vectors into a single data object:\n\n# A tibble of musicians and their instruments:\n\nmy_tibble &lt;- \n  tibble(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\"),\n    role = four_instruments)\n\nmy_tibble\n\nIt is pretty obvious that tibbles are printed differently than data frames. The differences don”t stop there though – they are also more restrictive.\nFor example, notice the kind of object that is returned when we use indexing to extract the second column in a data frame:\n\nmy_df[, 2]\n\nIt is an atomic vector! For a tibble, the class of object does not change (it is still a tibble):\n\nmy_tibble[, 2]\n\nTibbles are also restrictive about the use of $. In a data frame, columns can be extracted with partial matching:\n\nmy_df$musician\n\nmy_df$m\n\nIn a tibble, partial matching is not allowed:\n\nmy_tibble$musician\n\nmy_tibble$m\n\nFinally (though there are more differences), data frames will recycle values during their construction:\n\ndata.frame(\n  a = 1, \n  b = 1:4)\n\ndata.frame(\n  a = 1:2, \n  b = 1:4)\n\nWhereas tibbles will only recycle a single value:\n\ntibble(\n  a = 1, \n  b = 1:4)\n\ntibble(\n  a = 1:2,\n  b = 1:4)\n\n\n   Ugh … an error message!\nError messages are annoying but incredibly useful – we need to find a place in our hearts to appreciate them. With restrictions on a function”s usage or on the structure and composition of a data object, error messages stop us from making mistakes. When we generate an error message, it generally means that there is something that we don”t understand about the data that we are using or the function that”s throwing the error.\n\n\n3.0.3.1 Other ways of generating tibbles …\nWe can also construct a tibble by binding the vectors together with the bind_cols() function:\n\n# A tibble of musicians and their instruments:\n\nbind_cols(\n  musician = \n    c(\"roger\",\n      \"pete\",\n      \"john\",\n      \"keith\"),\n  role = four_instruments)\n\nBecause a tibble is a list and each column is a list item, we can also use bind_cols to combine two tibbles (by column):\n\n# A tibble of musicians and their instruments:\n\nbind_cols(\n  tibble(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\")),\n  tibble(\n    role = four_instruments))\n\nFinally, it is often useful to use the tribble() function to generate a tibble. This allows for row-wise tibble construction – in other words, the tribble() function allows us to generate a tibble with code that looks like the output. To do so, column names are preceded by a function operator (~) and separated by a comma. Values are typically written in the position that they will occupy in the resultant tibble.\n\n# Combining the two vectors into a tibble with tribble():\n\ntribble(\n  ~ musician, ~ role,\n  \"roger\",  \"vocals\",\n  \"pete\",   \"guitar\",\n  \"john\",   \"bass\",\n  \"keith\",  \"drums\")"
  },
  {
    "objectID": "global_assignment.html",
    "href": "global_assignment.html",
    "title": "5  Global assignment",
    "section": "",
    "text": "We covered assignments in some depth during the preliminary lessons. Recall that assignment, when used as a verb, refers to the process of assigning a reference (also called a name, key, binding, or assignment) to your global environment. R can use this reference to retrieve an object located within your computer’s memory.\nAs it relates to reading in data, assignment allows you to work with the files once you”ve read them in. Let”s read in three of our files of interest and assign names for those objects to the global environment:\n\n# Assign names to the global environment:\n\niris &lt;- \n  read_rds(\"data/raw/iris.rds\")\n\nportal_observations &lt;- \n  readxl::read_excel(\"data/raw/portal.xlsx\")\n\nTo see whether this worked, we can list the names assigned to our global environment with the function ls():\n\nls()\n\nNote: While ls() is often used programmatically, the above should be written in the console pane because we simply used it to look at our assigned names. No future code in your script will be dependent on this execution.\n\n   Follow best practices for assignments!\nThere are few “best practices” to consider when assigning names to the global environment:\n\nUse the &lt;- assignment operator whenever assigning a name to the global environment. Reserve the use of = to assignments within objects (e.g., c(roger = vocals)).\nWhen the subject of an assignment is generated with a function, place the assigned name and function on separate lines.\nAll global assignments should be written in the source pane.\nDo not assign the same name to multiple objects (including modified versions of an original object)\n\n\n\n5.0.1 Garbage collection\nIf an object does not contain a name, it is not saved in your computer’s memory. For example, in the code below the data associated with four_instruments.rds are read into memory just long enough to print the object, but are not stored in our computers’ memory:\n\nread_rds(\"data/raw/four_instruments.rds\")\n\nWe can also remove a name assigned to our global environment. When we do so, the our computer will no longer maintain that file in our computer’s memory. This process is known as garbage collection.\nWe can remove assignments from the global environment with the function rm():\n\nrm(portal_observations)\n\n\n Use rm() from within your script file!\nRemoving a name from your global environment can have downstream effects (i.e., impact code run later in a script). If rm() removes a name that was assigned to your global environment in your script file, avoid conducting this operation in the console pane.\n\nWe can check if this worked by listing the names assigned to our global environment with ls():\n\nls()\n\nIf we want to remove multiple assignments at the same time, we separate the names of each assignment with a comma:\n\nrm(four_instruments, iris)\n\nls()\n\nBecause the function ls() generates a character vector of assigned names, placing the function inside of rm() will remove all names assigned to the global environment. This is the second argument of the rm function, so we must specify the name of the argument in the function call (see ?rm):\n\n# Assign names to the global environment:\n\nfour_instruments &lt;- \n  read_lines(\"data/raw/four_instruments.txt\")\n\niris &lt;- \n  read_rds(\"data/raw/iris.rds\")\n\nportal_observations &lt;- \n  readxl::read_excel(\"data/raw/portal.xlsx\")\n\nrm(\n  list = ls())\n\nls()\n\nNotice in the above, that the function ls() is nested inside of rm(). R executes the nested function prior to the function it is nested within.\n\n Assign four_instruments and iris to your global environment\nWe will be using four_instruments.txt and iris.rds in a later part of this lesson. Please read in the files and assign their names to your global environment.\n\n\n   Manage your global environment!\nMemory is very costly, especially when our data are large. As assigned names represent objects stored in our memory, maintaining objects that we don”t need can slow down processing or even lead to aborted R sessions. Likewise, our global environment will often get cluttered with object names that we no longer need. This can generate a disorganized workflow. The utility of the Environment tab of the Environment pane is diminished if our environment contains loads of assignments. For both of these reasons, it is very important to remove unused assignments from our global environment."
  },
  {
    "objectID": "objects_review.html#functions",
    "href": "objects_review.html#functions",
    "title": "3  Objects in R",
    "section": "3.1 Functions",
    "text": "3.1 Functions\nA function in R is a type of object that contains a series of commands that are used to complete a given task.\n\n3.1.1 Functions – Digging deeper\nWe can view information about a function by typing its name in the console panel and hitting enter.\n\nmutate\n\nThe output above is not very informative, and this is often the case. R printed the name of the method the function uses to conduct its operation (UseMethod), where the body of the function is stored (bytecode), and the name of the package (namespace).\nThe namespace of a function is very important – it is the environment where the package’s objects are located. If we only want to view the namespace of a function, we can print this information with the function environment():\n\nenvironment(mutate)\n\nWe can view the methods associated with a function using the methods() function and supplying the name of the function we are interested in:\n\nmethods(mutate)\n\nWe can see that this function is powered by another named function, mutate.data.frame. The asterisk (*) means that the methods are not exported from the namespace of the package. This means that it is an internal function – it cannot be directly run on the user end.\nWe can access a function that is not exported to the namespace using the ::: operator. We supply the name of the package, which we determined by printing the name of the function in our console panel, the ::: operator, and the name of the method that the function uses:\n\ndplyr:::mutate.data.frame\n\n\n\n3.1.2 Operators\n\n\n3.1.3 Functions in packages"
  },
  {
    "objectID": "objects_review.html#common-data-objects",
    "href": "objects_review.html#common-data-objects",
    "title": "3  Objects in R",
    "section": "3.2 Common data objects",
    "text": "3.2 Common data objects\nIt is often useful to create your own data sets. I do so frequently to provide a basis for testing how a function works, running a simulation, or iteration (coming soon!).\n\n3.2.1 Atomic vectors\nAn atomic vector is a one-dimensional object where each value is of the same class. We can generate an atomic vector using the combine function, c():\n\n# A vector of musicians:\n\nc(\"roger\",\n  \"pete\",\n  \"john\",\n  \"keith\")\n\n# A vector of integers:\n\n1:4\n\n# A vector of double numeric values:\n\nc(1, 2, 3, 4)\n\nWe can view where an object is stored in our computer’s memory with the function lobstr::ref():\n\nlobstr::ref(\n  c(1, 2, 3)\n)\n\nWatch what happens, however,\nWe can assign a name to a vector using the &lt;- operator:\n\nmusicians &lt;-\n  c(\"roger\",\n    \"pete\",\n    \"john\",\n    \"keith\")\n\n\n All objects in an atomic vector must share the same class!\nNotice what happens when we use c() to combine two vectors of different classes:\n\nc(four_instruments, 1:4)\n\nBecause c() generates an atomic vector and all values in an atomic vector must be of the same class, the integer values were changed to characters. Knowing this can help find problems in a data set. For example, if you read in a dataset and there is a column that you believe should be numeric but has been converted to a character, it is likely that there is a character value hidden somewhere in the data.\n\n\n\n3.2.2 Lists\nAn atomic vector is, in a way, a restrictive type of list. A list is a one-dimensional object where values, which here are called list items, can be of any class.\nWe can generate a list with the list() function. Watch what happens when we combine four_instruments and 1:4 into a list:\n\nlist(four_instruments, 1:4)\n\nThe classes were maintained because lists do not have to be atomic.\nAdditionally, a list item does not have to be a single value – it can be any object:\n\nlist(musicians, four_instruments)\n\nNotice that the list items are not named with the list function by default. We can view this by nesting list() inside of the names() function.\n\nnames(\n  list(musicians, four_instruments))\n\nNames can be assigned to each item using the internal assignment operator (=). In the below, I store the list in memory by assigning the name my_list to the object, and assign names to each list item with the = assignment operator:\n\nnames(\n  list(\n    musicians = musicians,\n    four_instruments = four_instruments))\n\nBy naming the list items, I can extract the values associated with a name using the $ operator:\n\nlist(\n    musicians = musicians,\n    four_instruments = four_instruments)$four_instruments\n\nAn alternative to list() is the tidyverse function tibble::lst(). This function can be used to generate a list and maintain the names that were globally assigned to the child objects. The package tibble is part of the core tidyverse so, with tidyverse loaded you can call the function directly:\n\nlst(musicians, four_instruments)\n\nnames(\n  lst(musicians, four_instruments))\n\nlst(musicians, four_instruments)$four_instruments\n\n\n   Restrictions are annoying great!\nThe flexibility of lists makes them very powerful … unfortunately it also can make them difficult to work with and prone to errors. Restrictions in the behavior of objects makes it much easier to spot problems in our data.\n\n\n\n3.2.3 Tibbles\nA data frame is a special type of list. Data frames have two important restrictions that distinguish them from other types of lists:\n\nEach column in a data frame is a list item of equivalent length.\nThe data that comprise a column must be of the same class.\n\nWe can use the function data.frame() to combine two vectors into a single data object:\n\nmy_df &lt;- \n  data.frame(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\"),\n    role = four_instruments)\n\nmy_df\n\nTibbles are a special kind of data frame. In this course, we will use tibbles more than any other kind of data object.\nTo generate a tibble data frame, we can use the function tibble() to combine two vectors into a single data object:\n\n# A tibble of musicians and their instruments:\n\nmy_tibble &lt;- \n  tibble(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\"),\n    role = four_instruments)\n\nmy_tibble\n\nIt is pretty obvious that tibbles are printed differently than data frames. The differences don”t stop there though – they are also more restrictive.\nFor example, notice the kind of object that is returned when we use indexing to extract the second column in a data frame:\n\nmy_df[, 2]\n\nIt is an atomic vector! For a tibble, the class of object does not change (it is still a tibble):\n\nmy_tibble[, 2]\n\nTibbles are also restrictive about the use of $. In a data frame, columns can be extracted with partial matching:\n\nmy_df$musician\n\nmy_df$m\n\nIn a tibble, partial matching is not allowed:\n\nmy_tibble$musician\n\nmy_tibble$m\n\nFinally (though there are more differences), data frames will recycle values during their construction:\n\ndata.frame(\n  a = 1, \n  b = 1:4)\n\ndata.frame(\n  a = 1:2, \n  b = 1:4)\n\nWhereas tibbles will only recycle a single value:\n\ntibble(\n  a = 1, \n  b = 1:4)\n\ntibble(\n  a = 1:2,\n  b = 1:4)\n\n\n   Ugh … an error message!\nError messages are annoying but incredibly useful – we need to find a place in our hearts to appreciate them. With restrictions on a function”s usage or on the structure and composition of a data object, error messages stop us from making mistakes. When we generate an error message, it generally means that there is something that we don”t understand about the data that we are using or the function that”s throwing the error.\n\n\n3.2.3.1 Other ways of generating tibbles …\nWe can also construct a tibble by binding the vectors together with the bind_cols() function:\n\n# A tibble of musicians and their instruments:\n\nbind_cols(\n  musician = \n    c(\"roger\",\n      \"pete\",\n      \"john\",\n      \"keith\"),\n  role = four_instruments)\n\nBecause a tibble is a list and each column is a list item, we can also use bind_cols to combine two tibbles (by column):\n\n# A tibble of musicians and their instruments:\n\nbind_cols(\n  tibble(\n    musician = \n      c(\"roger\",\n        \"pete\",\n        \"john\",\n        \"keith\")),\n  tibble(\n    role = four_instruments))\n\nFinally, it is often useful to use the tribble() function to generate a tibble. This allows for row-wise tibble construction – in other words, the tribble() function allows us to generate a tibble with code that looks like the output. To do so, column names are preceded by a function operator (~) and separated by a comma. Values are typically written in the position that they will occupy in the resultant tibble.\n\n# Combining the two vectors into a tibble with tribble():\n\ntribble(\n  ~ musician, ~ role,\n  \"roger\",  \"vocals\",\n  \"pete\",   \"guitar\",\n  \"john\",   \"bass\",\n  \"keith\",  \"drums\")"
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "5  Assignment",
    "section": "",
    "text": "We covered assignments in some depth in the preliminary lessons. Recall that assignment, when used as a verb, refers to the process of adding a reference point (also called a name, key, binding, or assignment) to an object located within your computer’s memory.\nThere are two types of assignment that\nAs it relates to reading in data, assignment allows you to work with the files once you”ve read them in. Let”s read in three of our files of interest and assign names for those objects to the global environment:\n\n# Assign names to the global environment:\n\niris &lt;- \n  read_rds(\"data/raw/iris.rds\")\n\nportal_observations &lt;- \n  readxl::read_excel(\"data/raw/portal.xlsx\")\n\nTo see whether this worked, we can list the names assigned to our global environment with the function ls():\n\nls()\n\nNote: While ls() is often used programmatically, the above should be written in the console pane because we simply used it to look at our assigned names. No future code in your script will be dependent on this execution.\n\n   Follow best practices for assignments!\nThere are few “best practices” to consider when assigning names to the global environment:\n\nUse the &lt;- assignment operator whenever assigning a name to the global environment. Reserve the use of = to assignments within objects (e.g., c(roger = vocals)).\nWhen the subject of an assignment is generated with a function, place the assigned name and function on separate lines.\nAll global assignments should be written in the source pane.\nDo not assign the same name to multiple objects (including modified versions of an original object)\n\n\n\n5.0.1 Garbage collection\nIf an object does not contain a name, it is not saved in your computer’s memory. For example, in the code below the data associated with four_instruments.rds are read into memory just long enough to print the object, but are not stored in our computers’ memory:\n\nread_rds(\"data/raw/four_instruments.rds\")\n\nWe can also remove a name assigned to our global environment. When we do so, the our computer will no longer maintain that file in our computer’s memory. This process is known as garbage collection.\nWe can remove assignments from the global environment with the function rm():\n\nrm(portal_observations)\n\n\n Use rm() from within your script file!\nRemoving a name from your global environment can have downstream effects (i.e., impact code run later in a script). If rm() removes a name that was assigned to your global environment in your script file, avoid conducting this operation in the console pane.\n\nWe can check if this worked by listing the names assigned to our global environment with ls():\n\nls()\n\nIf we want to remove multiple assignments at the same time, we separate the names of each assignment with a comma:\n\nrm(four_instruments, iris)\n\nls()\n\nBecause the function ls() generates a character vector of assigned names, placing the function inside of rm() will remove all names assigned to the global environment. This is the second argument of the rm function, so we must specify the name of the argument in the function call (see ?rm):\n\n# Assign names to the global environment:\n\nfour_instruments &lt;- \n  read_lines(\"data/raw/four_instruments.txt\")\n\niris &lt;- \n  read_rds(\"data/raw/iris.rds\")\n\nportal_observations &lt;- \n  readxl::read_excel(\"data/raw/portal.xlsx\")\n\nrm(\n  list = ls())\n\nls()\n\nNotice in the above, that the function ls() is nested inside of rm(). R executes the nested function prior to the function it is nested within.\n\n Assign four_instruments and iris to your global environment\nWe will be using four_instruments.txt and iris.rds in a later part of this lesson. Please read in the files and assign their names to your global environment.\n\n\n   Manage your global environment!\nMemory is very costly, especially when our data are large. As assigned names represent objects stored in our memory, maintaining objects that we don”t need can slow down processing or even lead to aborted R sessions. Likewise, our global environment will often get cluttered with object names that we no longer need. This can generate a disorganized workflow. The utility of the Environment tab of the Environment pane is diminished if our environment contains loads of assignments. For both of these reasons, it is very important to remove unused assignments from our global environment."
  },
  {
    "objectID": "code_formatting.html#the-basic-rules-for-modern-r-code-formatting",
    "href": "code_formatting.html#the-basic-rules-for-modern-r-code-formatting",
    "title": "8  Best practices",
    "section": "8.2 The basic rules for modern R code formatting",
    "text": "8.2 The basic rules for modern R code formatting\nNote: Rules in blue can be carefully broken or have exceptions (see below), while rules in black are firm!\n\n8.2.1 Code spacing\nConsistent use of code spacing really enhances the readability of your code. Please adhere to the following:\nVertical spacing\nPlease ensure that you maintain exactly one blank line between:\n\nAdjacent code blocks\n\nBad:\n\n\nc(1, 2)\nlist(1, 2)\n\n\nGood:\n\n\nc(1, 2)\n\nlist(1, 2)\n\n\nException: The library() function\n\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\nCode blocks and comments (including section headers)\n\nBad:\n\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\nComments and section headers\n\nBad:\n\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\nImportant! There should be no vertical space elsewhere in your R script file!\nHorizontal spacing\nInclude a leading and trailing space for:\n\nAll assignment, arithmetic, and logical operators\n\nInclude a trailing, but not a leading space for:\n\nCommas\nThe ~ operator if the right-hand side of the formula is not a single identifier\nHash tags and comment text (including section headers)\n\nDo not include a leading or trailing space between:\n\nOpening parentheses or square bracket operators and adjacent code.\nThe ~ operator and adjacent code if the right-hand side of the formula is a single identifier.\nThe $ operator\nOpening parentheses or square bracket operators and adjacent code\n\n\n\n8.2.2 Assignment\n\nObjects that are used in the creation of a parent object and not used again should not be assigned to the global environment.\nAssigned names should not include a ..\nAssigned names should be in all lowercase with multiple words should be separate by a _ (i.e., snake_case).\nOnly use = when providing values to the formals of a function – for assigning to the global environment, use the &lt;- assignment operator.\nAll global assignments live on their own line if they are followed by a named R function.\n\n\n\n8.2.3 Functions\nRecall that functions may have names, but also include operators (e.g., :, [], {}, and (), =). Named functions can further be described as “R functions”, which are written in Program R, and “primitive functions” (e.g., c(), list()), which are written were written with a different programming language.\nPlease follow these rules when writing functions.\n\nIf a function contains four or more character arguments, place each argument on its own line.\n\nEach formal of a function (i.e., argument) lives on its own line\nThere should be no more than one call to a named function per line of code\n\n\nA quick notes for point-savvy students (just gimme my grade, nerd!): If you follow each of the rules above, I cannot take any points away for the formatting of your assignments. You can still end up with relatively ugly code even if you follow theses rules, but learning to know when to break the rules takes time and experience."
  },
  {
    "objectID": "code_formatting.html#exploring-these-rules",
    "href": "code_formatting.html#exploring-these-rules",
    "title": "8  Course style guide",
    "section": "8.3 Exploring these rules",
    "text": "8.3 Exploring these rules\nIn the video below, we will practice aligning a poorly formatted code with this style guide.\nBefore you begin:\n\nPlease open RStudio in your course project.\nOpen the script file code_formatting_practice.R.\nHit play!"
  },
  {
    "objectID": "code_formatting.html#exceptions-to-these-rules",
    "href": "code_formatting.html#exceptions-to-these-rules",
    "title": "8  Course style guide",
    "section": "8.4 Exceptions to these rules",
    "text": "8.4 Exceptions to these rules\nThe following provides instances in which the rules above can be broken (but don’t have to be!):\nRule: Objects that are used in the creation of a parent object and not used again should not be assigned to the global environment.\nException: Sometimes maintaining data in a previous state (e.g., raw data being read in) can be useful! If your dataset is particularly large (e.g., a data frame with more than 100,000 rows) or takes considerable processing time to generate, you may want to assign the name of the object to the global environment until you are sure you will not need it again.\nRule: No line of code should exceed 76 characters in width (the magic number of tidy coding)\nException: Sometimes exceeding the 76 character width is unavoidable when reading in data. Long file paths and URLs are examples of when this is the case. Note: If my file paths get exceedingly long, I often address this with the function file.path().\nRule: Each formal of a function lives on its own line.\nException: This rule can be broken if:\n\nThere are two formals assigned internally (e.g., data.frame(a = 1:2, b = 3:4))\nThere are four or fewer formals with no internal assignments (e.g., c(1, 1, 2, 3))\n\nRule: There should be no more than one call to a named function per line of code.\nException: This rule can be broken for primitive functions (e.g., c() in data.frame(a = 1:2, b = c(3, 5)))."
  },
  {
    "objectID": "code_formatting.html#setup",
    "href": "code_formatting.html#setup",
    "title": "8  Best practices",
    "section": "8.1 Setup",
    "text": "8.1 Setup\nPlease load the tidyverse library before starting with this tutorial:\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "code_formatting.html#course-rules-for-code-formatting",
    "href": "code_formatting.html#course-rules-for-code-formatting",
    "title": "8  Best practices",
    "section": "8.2 Course rules for code formatting",
    "text": "8.2 Course rules for code formatting\n\n8.2.1 Code spacing\nConsistent use of code spacing really enhances the readability of your code. Please adhere to the following:\n\n8.2.1.1 Vertical spacing\nPlease ensure that you maintain exactly one blank line between:\n\nAdjacent code blocks\n\nBad:\n\n\nc(1, 2)\nlist(1, 2)\n\n\nGood:\n\n\nc(1, 2)\n\nlist(1, 2)\n\n\nException: The library() function\n\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\nCode blocks and comments (including section headers)\n\nBad:\n\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\nComments and section headers\n\nBad:\n\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\nHorizontal spacing\nInclude a leading and trailing space for:\n\nAll assignment, arithmetic, and logical operators\n\nInclude a trailing, but not a leading space for:\n\nCommas\nThe ~ operator if the right-hand side of the formula is not a single identifier\nHash tags and comment text (including section headers)\n\nDo not include a leading or trailing space between:\n\nOpening parentheses or square bracket operators and adjacent code.\nThe ~ operator and adjacent code if the right-hand side of the formula is a single identifier.\nThe $ operator\nOpening parentheses or square bracket operators and adjacent code\n\n\n\n\n8.2.2 Assignment\n\nObjects that are used in the creation of a parent object and not used again should not be assigned to the global environment.\nAssigned names should not include a ..\nAssigned names should be in all lowercase with multiple words should be separate by a _ (i.e., snake_case).\nOnly use = when providing values to the formals of a function – for assigning to the global environment, use the &lt;- assignment operator.\nAll global assignments live on their own line if they are followed by a named R function.\n\n\n\n8.2.3 Functions\nRecall that functions may have names, but also include operators (e.g., :, [], {}, and (), =). Named functions can further be described as “R functions”, which are written in Program R, and “primitive functions” (e.g., c(), list()), which are written were written with a different programming language.\nPlease follow these rules when writing functions.\n\nIf a function contains four or more character arguments, place each argument on its own line.\n\nEach formal of a function (i.e., argument) lives on its own line\nThere should be no more than one call to a named function per line of code\n\n\nA quick notes for point-savvy students (just gimme my grade, nerd!): If you follow each of the rules above, I cannot take any points away for the formatting of your assignments. You can still end up with relatively ugly code even if you follow theses rules, but learning to know when to break the rules takes time and experience."
  },
  {
    "objectID": "code_formatting.html#code-spacing",
    "href": "code_formatting.html#code-spacing",
    "title": "8  Course style guide",
    "section": "8.1 Code spacing",
    "text": "8.1 Code spacing\nConsistent use of code spacing really enhances the readability of your code. Please adhere to the following:\n\n8.1.1 Vertical spacing\nPlease ensure that you maintain exactly one blank line between:\n\nAdjacent code blocks†\n\nBad:\n\n\nc(1, 2)\nlist(1, 2)\n\n\nGood:\n\n\nc(1, 2)\n\nlist(1, 2)\n\n\nException: The library() function\n\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\nCode blocks and comments (including section headers)†\n\nBad:\n\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\nComments and section header comments†\n\nBad:\n\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\n† The tidyverse style guide gives no recommendations for vertical spacing in code. I believe that vertical spacing, as defined here, helps differentiate between steps.\n\n\n8.1.2 Horizontal spacing\nInclude a leading and trailing space for:\n\nAll assignment, arithmetic, and logical operators\n\nBad:\n\n\nmy_vector&lt;-c(1, 2)\n\nmy_vector&lt;- c(1, 2)\n\nmy_vector &lt;-c(1, 2)\n\nmy_vector +1\n\nmy_vector+ 1\n\n\nGood:\n\n\nmy_vector &lt;- c(1, 2) + 1\n\nmy_vector + 1\n\nException: More than one space can be added before the = assignment operator if it improves alignment:\n\ntribble(\n  boy   = \"hello\",\n  howdy = \"world\" )\n\n\nInclude a (single) trailing, but not a leading space for:\n\nCommas\n\nBad:\n\n\nc(1,2)\n\nc(1 ,2)\n\nc(1 , 2)\n\n\nGood:\n\n\nc(1, 2)\n\nException†: More than one space can be added after a comma if it improves alignment:\n\ntribble(\n  ~ a,     ~ b,\n  \"hello\", \"world\")\n\n† The tidyverse style guide provides this exception for assignment operators, but it is unclear if they also consider extra spaces are acceptable after commas.\n\n\nThe ~ operator†\n\nBad:\n\n\nmy_tibble &lt;- \n  tribble(\n    ~boy, ~howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;- \n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n† The tidyverse style guide recommends that “single-sided formulas when the right-hand side is a single identifier” should not be followed by a trailing space. I have removed this requirement simply because examples of more complex right-hand identifiers will not be addressed until Module 5. No code formatting penalty will be enforced when the tidyverse style conditions are met.\n\n\nHash tags and comment text (including section headers)\n\nBad:\n\n\n#My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n#My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\nDo not include a leading or trailing space between:\n\nParentheses† or square bracket operators and adjacent code\n\nBad:\n\n\nmy_vector &lt;- c (1, 2)\n\nmy_vector &lt;- c( 1, 2)\n\nmy_vector &lt;- c(1, 2 )\n\nmy_vector [1]\n\nmy_vector[ 1]\n\n\nGood:\n\n\nmy_vector &lt;- c(1, 2)\n\nmy_vector[1]\n\n† The tidyverse style guide recommends including a space with before the parentheses when using the control flow operators for () and if (). These functions will not be addressed until Module 5, thus I have chosen to simplify this style guide by making the rule universal across course content.\n\n\nThe $ operator\n\nBad:\n\n\nmy_tibble $howdy\n\nmy_tibble$ howdy\n\n\nGood:\n\n\nmy_tibble$howdy"
  },
  {
    "objectID": "code_formatting.html#functions",
    "href": "code_formatting.html#functions",
    "title": "8  Course style guide",
    "section": "8.3 Functions",
    "text": "8.3 Functions\nRecall that functions may have names, but also include operators (e.g., :, [], {}, and (), =).\nPlease follow these rules when using named functions ().\n\nIf you provide three or more arguments to a named function, place each argument on its own line †.\n\n\nBad:\n\nc(\"guitar\", \"bass\", \"drums\")\n\nGood:\n\nc(\"guitar\",\n  \"bass\",\n  \"drums\")\n\nException, c() and list() with numeric values: When using the c() or list() functions, you may include up to five values on the same line if the values being combined are one to three digit numeric values:\n\nc(3, 5, 8, 13, 21)\n\n† The tidyverse style guide recommends a limit to the width of a line but does not contain a recommendation for the the number of arguments in a function.\n\n\nAlways spell out TRUE and FALSE.\n\n\nBad:\n\nmean(\n  c(1, 2, NA),\n  na.rm = T)\n\nGood:\n\nmean(\n  c(1, 2, NA),\n  na.rm = TRUE)\n\n\n\nWith nested functions, include no more than one named function per line (operators are okay)†.\n\n\nBad:\n\nmean(c(1, 2))\n\nGood:\n\nmean(\n  c(1, 2, NA),\n  na.rm = TRUE)\n\nException: If the inner function is used to calculate a summary statistic of the data object (e.g., the functions mean(), n(), and length()):\n\nlist(1, mean(my_vector))\n\nsummarize(my_tibble, n = n())\n\n\n\nWhen chaining together functions with a pipe operator (|&gt;), the chained functions should not occupy the same line of code†.\n\n\nBad:\n\nc(1, 2) |&gt; mean()\n\nmy_tibble |&gt; summarize(n = n())\n\nGood:\n\nc(1, 2) |&gt; \n  mean()\n\nmy_tibble |&gt; \n  summarize(n = n())\n\n† The tidyverse style guide makes an exception with one-step pipes. I have simplified this to include all piped statements."
  },
  {
    "objectID": "code_formatting.html#pipes",
    "href": "code_formatting.html#pipes",
    "title": "8  Course style guide",
    "section": "8.3 Pipes",
    "text": "8.3 Pipes"
  },
  {
    "objectID": "code_formatting.html#assignment",
    "href": "code_formatting.html#assignment",
    "title": "8  Course style guide",
    "section": "8.3 Assignment",
    "text": "8.3 Assignment\nPlace no more than one assignment operator (=) or (&lt;-) per line of code†.\n\nBad:\n\nmy_instruments &lt;- c(pete = \"guitar\")\n\nc(pete = \"guitar\", john = \"bass\")\n\nGood:\n\nmy_instruments &lt;- \n  c(pete = \"guitar\")\n\nc(pete = \"guitar\", \n  john = \"bass\")\n\n\nPlace no more than one assignment operator (=) or (&lt;-) per line of code.\nAssigned names:\n\nShould not include a .:\n\nBad:\n\n\nmy.tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nGood:\n\n\nmy.tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nAssigned names should be in all lowercase with multiple words should be separate by a _ (i.e., snake_case).\n\nBad:\n\n\nmyTibble &lt;-\n  tribble(\n    ~ Boy, ~ Howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nOnly use = when providing values to the formals of a function – for assigning to the global environment, use the &lt;- assignment operator:\n\nBad:\n\n\nmy_tibble =\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nAll global assignments live on their own line if they are followed by a chained operation or a function that occupies more than one line of code:\n\n\n\nmy_tibble &lt;- tribble(\n  ~ boy, ~ howdy,\n  1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nA quick notes for point-savvy students (just gimme my grade, nerd!): If you follow each of the rules above, I cannot take any points away for the formatting of your assignments. You can still end up with relatively ugly code even if you follow theses rules, but learning to know when to break the rules takes time and experience."
  },
  {
    "objectID": "code_formatting.html#assignments",
    "href": "code_formatting.html#assignments",
    "title": "8  Course style guide",
    "section": "8.4 Assignments",
    "text": "8.4 Assignments\nPlace no more than one assignment operator (=) or (&lt;-) per line of code†.\n\nBad:\n\nmy_instruments &lt;- c(pete = \"guitar\")\n\nc(pete = \"guitar\", john = \"bass\")\n\nGood:\n\nmy_instruments &lt;- \n  c(pete = \"guitar\")\n\nc(pete = \"guitar\", \n  john = \"bass\")\n\n\nOnly use = when providing values to the formals of a function – for assigning to the global environment, use the &lt;- assignment operator:\nBad:\n\n\nmy_tibble =\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nAssigned names should not include a ., should be in lowercase, and spaces between words should be separated by a _ (i.e., snake_case).:\n\nBad:\n\nmy.phrases &lt;-\n  tribble(\n    ~ boyHowdy, ~ HelloWorld,\n    1, 2)\n\nGood:\n\nmy_phrases &lt;-\n  tribble(\n    ~ boy_howdy, ~ hello_world,\n    1, 2)\n\n\nAll global assignments live on their own line if they are followed by a function or chained operation that occupies more than one line of code†:\n\nBad:\n\nmy_tibble &lt;- tribble(\n  ~ boy, ~ howdy,\n  1, 2)\n\nGood:\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nA quick notes for point-savvy students (just gimme my grade, nerd!): If you follow each of the rules above, I cannot take any points away for the formatting of your assignments. You can still end up with relatively ugly code even if you follow theses rules, but learning to know when to break the rules takes time and experience."
  },
  {
    "objectID": "code_formatting.html#whitespace",
    "href": "code_formatting.html#whitespace",
    "title": "8  Course style guide",
    "section": "8.2 Whitespace",
    "text": "8.2 Whitespace\nConsistent use of whitespace really enhances the readability of your code. Please adhere to the following:\n\n8.2.1 Vertical spacing\nPlease ensure that you maintain exactly one blank line between:\n\nAdjacent code blocks†\n\nBad:\n\n\nc(1, 2)\nlist(1, 2)\n\n\nGood:\n\n\nc(1, 2)\n\nlist(1, 2)\n\n\nException: The library() function\n\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\nCode blocks and comments (including section headers)†\n\nBad:\n\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\nComments and section header comments†\n\nBad:\n\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\n† The tidyverse style guide gives no recommendations for vertical spacing in code. I believe that vertical spacing, as defined here, helps differentiate between steps.\n\n\n8.2.2 Horizontal spacing\nInclude a leading and trailing space for all assignment, arithmetic, and logical operators\n\nBad:\n\nmy_vector&lt;-c(1, 2)\n\nmy_vector&lt;- c(1, 2)\n\nmy_vector &lt;-c(1, 2)\n\nmy_vector +1\n\nmy_vector+ 1\n\nGood:\n\nmy_vector &lt;- c(1, 2) + 1\n\nmy_vector + 1\n\nException: More than one space can be added before the = assignment operator if it improves alignment:\n\ntribble(\n  boy   = \"hello\",\n  howdy = \"world\" )\n\n\nInclude a (single) leading space for pipe operators (|&gt;).\n\nBad:\n\nmy_vector|&gt;\n  mean()\n\nGood:\n\nmy_vector |&gt;\n  mean()\n\n\nInclude a (single) trailing, but not a leading space for:\n\nCommas\n\nBad:\n\n\nc(1,2)\n\nc(1 ,2)\n\nc(1 , 2)\n\n\nGood:\n\n\nc(1, 2)\n\nException†: More than one space can be added after a comma if it improves alignment:\n\ntribble(\n  ~ a,     ~ b,\n  \"hello\", \"world\")\n\n† The tidyverse style guide provides this exception for assignment operators, but it is unclear if they also consider extra spaces are acceptable after commas.\n\n\nThe ~ operator†\n\nBad:\n\n\nmy_tibble &lt;- \n  tribble(\n    ~boy, ~howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;- \n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n† The tidyverse style guide recommends that “single-sided formulas when the right-hand side is a single identifier” should not be followed by a trailing space. I have removed this requirement simply because examples of more complex right-hand identifiers will not be addressed until Module 5. No code formatting penalty will be enforced when the tidyverse style conditions are met.\n\n\nHash tags and comment text (including section headers)\n\nBad:\n\n\n#My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n#My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\nDo not include a leading or trailing space between:\n\nParentheses† or square bracket operators and adjacent code\n\nBad:\n\n\nmy_vector &lt;- c (1, 2)\n\nmy_vector &lt;- c( 1, 2)\n\nmy_vector &lt;- c(1, 2 )\n\nmy_vector [1]\n\nmy_vector[ 1]\n\n\nGood:\n\n\nmy_vector &lt;- c(1, 2)\n\nmy_vector[1]\n\n† The tidyverse style guide recommends including a space with before the parentheses when using the control flow operators for () and if (). These functions will not be addressed until Module 5, thus I have chosen to simplify this style guide by making the rule universal across course content.\n\n\nThe $ operator\n\nBad:\n\n\nmy_tibble $howdy\n\nmy_tibble$ howdy\n\n\nGood:\n\n\nmy_tibble$howdy"
  },
  {
    "objectID": "code_formatting.html#style-guide-in-brief",
    "href": "code_formatting.html#style-guide-in-brief",
    "title": "8  Course style guide",
    "section": "8.1 Style guide, in brief",
    "text": "8.1 Style guide, in brief\n\n8.1.1 Operators\n\nAssignment (&lt;-, =):\n\nAlways use the &lt;- operator for global assignment.\nSeparate assignment operators from surrounding code with one leading and trailing space. Exception: You can add more than one space before the = operator if it improves code block alignment.\nPlace no more than one assignment operator (= or &lt;-) per line of code†.\nAssigned names should be written in snake_case.\n\nPipe operators (|&gt;):\n\nInclude one leading space before pipe operators.\nCode that follows a pipe operator should be placed on a new line†.\nPiped code should be indented two spaces (one tab stop) relative to the first step of the chain.\n\nArithmetic (e.g., +, *, /) and logical operators (e.g., ==, !=, %in%) should be separated from the adjacent code with one leading and trailing space. Exception: Negation (!) operators should not be separated from adjacent code.\nParentheses ((...))†, extraction ([], [[]], $), and colon operators (:, ::) should not be preceded or followed by a space.\nFormula operators (~):\n\nInclude one leading and trailing space for two-sided formulas.\nDo not include a trailing space if ~ is used in a single-sided formula with a single identifier.\nDo include a trailing space if ~ is followed by function (including operators).\n\n\n\n\n8.1.2 Code blocks and comments:\n\nMaintain one blank line between code blocks†. Exception: Do not separate adjacent library() functions with a blank line.\nMaintain one blank line between code blocks and comments†.\nHashtags (#) should be separated from comment text by one trailing space.\nCode should not exceed 80 characters in width (if it is avoidable).\nInclude no more than one named function per line of code (i.e., operators are okay)†. Exception: Nested functions where the inner function is the combine function (c()) or functions used to calculate summary statistics of a data object (e.g., mean(), n(), and length()).\nNested functions should not be nested deeper than two levels (use a pipe instead!)† and each level should be indented two spaces (one tab stop) relative to the parent function.\n\n\n\n8.1.3 Arguments in a function\n\nIf you provide three or more arguments to a named function, place each argument on its own line†. Exception: When using the c() or list() functions, you may include up to five numeric values.\nLogicals: Spell out TRUE and FALSE in a function’s argument.\nIf you modify the default behavior of a function’s argument, include the name of the argument.\nCharacter values: Use double-quotes (\"example\") when creating character vectors.\nCommas should be followed by one trailing space, but not a leading space. Exception: More than one space can be added after a comma if it improves the alignment within a code block."
  },
  {
    "objectID": "code_formatting.html#whitespace-1",
    "href": "code_formatting.html#whitespace-1",
    "title": "8  Course style guide",
    "section": "8.2 Whitespace",
    "text": "8.2 Whitespace\nConsistent use of whitespace really enhances the readability of your code. Please adhere to the following:\n\n8.2.1 Vertical spacing\nPlease ensure that you maintain exactly one blank line between:\n\nAdjacent code blocks†\n\nBad:\n\n\nc(1, 2)\nlist(1, 2)\n\n\nGood:\n\n\nc(1, 2)\n\nlist(1, 2)\n\n\nException: The library() function\n\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\nCode blocks and comments (including section headers)†\n\nBad:\n\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\nComments and section header comments†\n\nBad:\n\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\n† The tidyverse style guide gives no recommendations for vertical spacing in code. I believe that vertical spacing, as defined here, helps differentiate between steps.\n\n\n8.2.2 Horizontal spacing\nInclude a leading and trailing space for all assignment, arithmetic, and logical operators\n\nBad:\n\nmy_vector&lt;-c(1, 2)\n\nmy_vector&lt;- c(1, 2)\n\nmy_vector &lt;-c(1, 2)\n\nmy_vector +1\n\nmy_vector+ 1\n\nGood:\n\nmy_vector &lt;- c(1, 2) + 1\n\nmy_vector + 1\n\nException: More than one space can be added before the = assignment operator if it improves alignment:\n\ntribble(\n  boy   = \"hello\",\n  howdy = \"world\" )\n\n\nInclude a (single) leading space for pipe operators (|&gt;).\n\nBad:\n\nmy_vector|&gt;\n  mean()\n\nGood:\n\nmy_vector |&gt;\n  mean()\n\n\nInclude a (single) trailing, but not a leading space for:\n\nCommas\n\nBad:\n\n\nc(1,2)\n\nc(1 ,2)\n\nc(1 , 2)\n\n\nGood:\n\n\nc(1, 2)\n\nException†: More than one space can be added after a comma if it improves alignment:\n\ntribble(\n  ~ a,     ~ b,\n  \"hello\", \"world\")\n\n† The tidyverse style guide provides this exception for assignment operators, but it is unclear if they also consider extra spaces are acceptable after commas.\n\n\nThe ~ operator†\n\nBad:\n\n\nmy_tibble &lt;- \n  tribble(\n    ~boy, ~howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;- \n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n† The tidyverse style guide recommends that “single-sided formulas when the right-hand side is a single identifier” should not be followed by a trailing space. I have removed this requirement simply because examples of more complex right-hand identifiers will not be addressed until Module 5. No code formatting penalty will be enforced when the tidyverse style conditions are met.\n\n\nHash tags and comment text (including section headers)\n\nBad:\n\n\n#My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n#My list:\n\nlist(1, 2)\n\n\nGood:\n\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\nDo not include a leading or trailing space between:\n\nParentheses† or square bracket operators and adjacent code\n\nBad:\n\n\nmy_vector &lt;- c (1, 2)\n\nmy_vector &lt;- c( 1, 2)\n\nmy_vector &lt;- c(1, 2 )\n\nmy_vector [1]\n\nmy_vector[ 1]\n\n\nGood:\n\n\nmy_vector &lt;- c(1, 2)\n\nmy_vector[1]\n\n† The tidyverse style guide recommends including a space with before the parentheses when using the control flow operators for () and if (). These functions will not be addressed until Module 5, thus I have chosen to simplify this style guide by making the rule universal across course content.\n\n\nThe $ operator\n\nBad:\n\n\nmy_tibble $howdy\n\nmy_tibble$ howdy\n\n\nGood:\n\n\nmy_tibble$howdy"
  },
  {
    "objectID": "code_formatting.html#style-guide-explained",
    "href": "code_formatting.html#style-guide-explained",
    "title": "8  Course style guide",
    "section": "8.2 Style guide, explained",
    "text": "8.2 Style guide, explained\n\n8.2.1 Whitespace\nConsistent use of whitespace really enhances the readability of your code. Please adhere to the following:\n\n●Vertical whitespace helps visually break your code up into steps and is especially useful when code blocks occupy more than one line. Please maintain exactly one blank line between:\n\n\n○ Adjacent code blocks†: This makes it easier to select blocks of code when exploring output or debugging.\n\n\nBad:\n\nc(1, 2)\nlist(1, 2)\n\nGood:\n\nc(1, 2)\n\nlist(1, 2)\n\nException: The library() function: Because it is rarely necessary run or debug a single library loading task!\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\n○ Code blocks and comments (including section headers)†: This helps differentiate between code and comments.\n\n\nBad:\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\nGood:\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\n○ Comments and section header comments†: This helps section headers stand out.\n\n\nBad:\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\nGood:\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\n\n† The tidyverse style guide gives no recommendations for vertical whitespace in code. I believe that vertical spacing rules defined here really helps differentiate between steps and generate much more readable code.\n\n\n● Horizontal whitespace:\n\n\n○ Include a leading and trailing space for all assignment, arithmetic, and logical operators\n\n\nBad:\n\nmy_vector&lt;-c(1, 2)\n\nmy_vector&lt;- c(1, 2)\n\nmy_vector &lt;-c(1, 2)\n\nmy_vector +1\n\nmy_vector+ 1\n\nGood:\n\nmy_vector &lt;- c(1, 2) + 1\n\nmy_vector + 1\n\nException: More than one space can be added before the = assignment operator if it improves alignment:\n\ntribble(\n  boy   = \"hello\",\n  howdy = \"world\" )\n\n\n\n○ Include a (single) leading space for pipe operators (|&gt;).\n\n\nBad:\n\nmy_vector|&gt;\n  mean()\n\nGood:\n\nmy_vector |&gt;\n  mean()\n\n\n\n○ For multi-line code blocks, indent two spaces (a tab stop) relative to the parent object or process:\n\n\nBad:\n\nmy_vector |&gt;\nmean()\n\nmean(\n    c(1, 1, 2),\nna.rm = TRUE)\n\nlist(\"guitar\",\n     \"bass\",\n     \"drums\")\n\nGood:\n\nmy_vector |&gt;\n  mean()\n\nmean(\n  c(1, 1, 2),\n  na.rm = TRUE)\n\nlist(\n  \"guitar\",\n  \"bass\",\n  \"drums\")\n\n\n\n○ Include a (single) trailing, but not a leading space for:\n\n\n■ Commas: Spacing should be equivalent to the spacing used in regular English writing.\n\n\nBad:\n\nc(1,2)\n\nc(1 ,2)\n\nc(1 , 2)\n\nGood:\n\nc(1, 2)\n\nException: More than one space can be added after a comma if it improves alignment:\n\ntribble(\n  ~ a,     ~ b,\n  \"hello\", \"world\")\n\n\n\n■ The formula operator (~)†\n\n\nBad:\n\nmy_tibble &lt;- \n  tribble(\n    ~boy, ~howdy,\n    1, 2)\n\nGood:\n\nmy_tibble &lt;- \n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n† The tidyverse style guide recommends that “single-sided formulas when the right-hand side is a single identifier” should not be followed by a trailing space. I have removed this requirement simply because examples of more complex right-hand identifiers will not be addressed until Module 5. No code formatting penalty will be enforced when the tidyverse style conditions are met.\n\n\n■ Hash tags and comment text (including section headers)\n\n\nBad:\n\n#My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n#My list:\n\nlist(1, 2)\n\nGood:\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\n○ Do not include a leading or trailing space between:\n\n\n■ Parentheses† or square bracket operators and adjacent code\n\n\nBad:\n\nmy_vector &lt;- c (1, 2)\n\nmy_vector &lt;- c( 1, 2)\n\nmy_vector &lt;- c(1, 2 )\n\nmy_vector [1]\n\nmy_vector[ 1]\n\nGood:\n\nmy_vector &lt;- c(1, 2)\n\nmy_vector[1]\n\n† The tidyverse style guide recommends including a space with before the parentheses when using the control flow operators for () and if (). These functions will not be addressed until Module 5, thus I have chosen to simplify this style guide by making the rule universal across course content.\n\n\n■ The $ operator\n\n\nBad:\n\nmy_tibble $howdy\n\nmy_tibble$ howdy\n\nGood:\n\nmy_tibble$howdy\n\n\n\n\n8.2.2 Line breaks\n\n● No line of code should exceed 80 characters in width.\n\n\nBad:\n\nbrood_x_cicadas &lt;- c(\"Magicicada cassini\", \"Magicicada septendecim\", \"Magicicada septendecula\")\n\nGood:\n\nbrood_x_cicadas &lt;- \n  c(\"Magicicada cassini\", \"Magicicada septendecim\", \"Magicicada septendecula\")\n\n# Or (even better):\n\nbrood_x_cicadas &lt;- \n  c(\"Magicicada cassini\",\n    \"Magicicada septendecim\", \n    \"Magicicada septendecula\")\n\nException: Wide lines are sometimes unavoidable with long file paths or URLs:\n\npings &lt;- \"https://github.com/kpaxton75/EcolEvol.Manuscript_Optimizing.Trilateration/blob/main/BeepData_Example.rds\"\n\nIn such cases, just do the best you can:\n\npings &lt;- \n  \"https://github.com/kpaxton75/EcolEvol.Manuscript_Optimizing.Trilateration/blob/main/BeepData_Example.rds\"\n\n\n\n● Place no more than one assignment operator (=) or (&lt;-) per line of code†.\n\n\nBad:\n\ngreetings &lt;- rep(c(\"hello world\"), times = 2)\n\nGood:\n\ngreetings &lt;- \n  rep(c(\"hello world\"), times = 2)\n\n\n\n● Place name &lt;- on its own line if the code block is more than one line.\n\n\nBad:\n\nmy_tibble &lt;- tribble(\n  ~ boy, ~ howdy,\n  1, 2)\n\nGood:\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nIf you provide four or more arguments to a named function, place each argument on its own line †.\n\n\nBad:\n\nc(\"guitar\", \"bass\", \"drums\", \"vocals\")\n\nGood:\n\nc(\"guitar\",\n  \"bass\",\n  \"drums\",\n  \"vocals\")\n\nException, c() and list() with numeric values: When using the c() or list() functions, you may include up to five values on the same line if the values being combined are one to three digit numeric values:\n\nc(3, 5, 8, 13, 21)\n\n† The tidyverse style guide recommends a limit to the width of a line but does not recommend a criteria for achieving this.\n\n\nAlways spell out TRUE and FALSE.\n\n\nBad:\n\nmean(\n  c(1, 2, NA),\n  na.rm = T)\n\nGood:\n\nmean(\n  c(1, 2, NA),\n  na.rm = TRUE)\n\n\n\nWith nested functions, include no more than one named function per line (operators are okay)†.\n\n\nBad:\n\nmean(c(1, 2))\n\nGood:\n\nmean(\n  c(1, 2, NA),\n  na.rm = TRUE)\n\nException: If the inner function is used to calculate a summary statistic of the data object (e.g., the functions mean(), n(), and length()):\n\nlist(1, mean(my_vector))\n\nsummarize(my_tibble, n = n())\n\n\n\nWhen chaining together functions with a pipe operator (|&gt;), the chained functions should not occupy the same line of code†.\n\n\nBad:\n\nc(1, 2) |&gt; mean()\n\nmy_tibble |&gt; summarize(n = n())\n\nGood:\n\nc(1, 2) |&gt; \n  mean()\n\nmy_tibble |&gt; \n  summarize(n = n())\n\n† The tidyverse style guide makes an exception with one-step pipes. I have simplified this to include all piped statements.\n\n\n\n8.2.3 Assignments/names\nPlace no more than one assignment operator (=) or (&lt;-) per line of code†.\n\nBad:\n\nmy_instruments &lt;- c(pete = \"guitar\")\n\nc(pete = \"guitar\", john = \"bass\")\n\nGood:\n\nmy_instruments &lt;- \n  c(pete = \"guitar\")\n\nc(pete = \"guitar\", \n  john = \"bass\")\n\n\nOnly use = when providing values assigned to the formals of a function – for assigning to the global environment, use the &lt;- assignment operator:\nBad:\n\n\nmy_tibble =\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nAssigned names should not include a ., should be in lowercase, and spaces between words should be separated by a _ (i.e., snake_case).:\n\nBad:\n\nmy.phrases &lt;-\n  tribble(\n    ~ boyHowdy, ~ HelloWorld,\n    1, 2)\n\nGood:\n\nmy_phrases &lt;-\n  tribble(\n    ~ boy_howdy, ~ hello_world,\n    1, 2)"
  },
  {
    "objectID": "code_formatting.html#style-guide-in-depth",
    "href": "code_formatting.html#style-guide-in-depth",
    "title": "8  Course style guide",
    "section": "8.2 Style guide, in-depth",
    "text": "8.2 Style guide, in-depth\n\n8.2.1 Operators\n\n● Assignment (&lt;-, =):\n\n\n○ Always use the &lt;- operator for global assignment.\n\n\nBad:\n\nmy_vector = c(1, 2)\n\nGood:\n\nmy_vector &lt;- c(1, 2)\n\n\n\n○ Separate assignment operators from surrounding code with one leading and trailing space.\n\n\nBad:\n\nsayings&lt;-\n  tibble(\n    country=c(\"boy\", \"howdy\"),\n    nerdy =c(\"hello\", \"world\"),\n    formal= c(\"warm\", \"wishes\"))\n\nGood:\n\nsayings &lt;-\n  tibble(\n    country = c(\"boy\", \"howdy\"),\n    nerdy = c(\"hello\", \"world\"),\n    formal = c(\"warm\", \"wishes\"))\n\nException: You can add more than one space before the = operator if it improves code block alignment.\n\nsayings &lt;-\n  tibble(\n    country = c(\"boy\", \"howdy\"),\n    nerdy   = c(\"hello\", \"world\"),\n    formal  = c(\"warm\", \"wishes\"))\n\n\n\n○ Place no more than one assignment operator (= or &lt;-) per line of code†.\n\n\nBad:\n\ngreetings &lt;- rep(c(\"hello world\"), times = 2)\n\nGood:\n\ngreetings &lt;- \n  rep(c(\"hello world\"), times = 2)\n\n\n\n○ Assigned names should be written in snake_case.\n\n\nBad:\n\nmy.phrases &lt;-\n  tribble(\n    ~boyHowdy, ~HelloWorld,\n    1, 2)\n\nGood:\n\nmy_phrases &lt;-\n  tribble(\n    ~boy_howdy, ~hello_world,\n    1, 2)\n\n\n\n● Pipe operators (|&gt;):\n\n\n○ Include one leading space before pipe operators.\n\n\nBad:\n\nc(1, 2)|&gt;\n  mean()\n\nGood:\n\nc(1, 2) |&gt;\n  mean()\n\n\n\n○ Code that follows a pipe operator should be placed on a new line†.\n\n\nBad:\n\nc(1, 2) |&gt; mean()\n\nGood:\n\nc(1, 2) |&gt;\n  mean()\n\n\n\n○ Piped code and comments should be indented two spaces (one tab stop) relative to the first step of the chained process.\n\n\nBad:\n\nc(1, 2) |&gt;\nmean()\n\nc(1, 2) |&gt;\n  \n# Calculate mean:\n  \n  mean()\n\nGood:\n\nc(1, 2) |&gt;\n  mean()\n\nc(1, 2) |&gt;\n  \n  # Calculate mean:\n  \n  mean()\n\n\n\n● Arithmetic (e.g., +, *, /) and logical operators (e.g., ==, !=, %in%) should be separated from the adjacent code with one leading and trailing space.\n\n\nBad:\n\n1/2\n1+ 2\n1 ==2\n\nGood:\n\n1 / 2\n1 + 2\n1 == 2\n\nException: Negation (!) operators should not be separated from adjacent code.\n\n!1 == 2\n\n\n\n● Parentheses ((...))†, extraction ([], [[]], $), and colon operators (:, ::) should not be preceded or followed by a space.\n\n\nBad:\n\nc (1, 2)\n\nsayings[1, 2 ]\n\nsayings$ nerdy\n\nGood:\n\nc(1, 2)\n\nsayings[1, 2]\n\nsayings$nerdy\n\n\n\n● Formula operators (~):\n\n\n○ Include one leading and trailing space for two-sided formulas.\n\n\nBad:\nGood:\n\n\n○ Do not include a trailing space if ~ is used in a single-sided formula with a single identifier.\n\n\nBad:\nGood:\n\n\n○ Do include a trailing space if ~ is followed by function (including operators).\n\n\nBad:\nGood:\n\n\n\n8.2.2 Code blocks and comments:\n\n● Maintain one blank line between code blocks†.\n\n\nBad:\n\nc(1, 2)\nlist(1, 2)\n\nGood:\n\nc(1, 2)\n\nlist(1, 2)\n\nException: Do not separate adjacent library() functions with a blank line.\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\n● Maintain one blank line between code blocks and comments†.\n\n\nBad:\n\n# A poorly placed section header -----------------------------\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\nGood:\n\n# A well-placed section header --------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\n● Hashtags (#) should be separated from comment text by one trailing space.\n\n\nBad:\n\n#A well-placed section header ---------------------------------\n\n#My atomic vector:\n\nGood:\n\n# A well-placed section header --------------------------------\n\n# My atomic vector:\n\n\n\n● Code should not exceed 80 characters in width (if it is avoidable).\n\n\nBad:\n\nbrood_x_cicadas &lt;- c(\"Magicicada cassini\", \"Magicicada septendecim\", \"Magicicada septendecula\")\n\nGood:\n\nbrood_x_cicadas &lt;- \n  c(\"Magicicada cassini\", \"Magicicada septendecim\", \"Magicicada septendecula\")\n\n# Or (even better):\n\nbrood_x_cicadas &lt;- \n  c(\"Magicicada cassini\",\n    \"Magicicada septendecim\", \n    \"Magicicada septendecula\")\n\n\n\n● Include no more than one named function per line of code (i.e., operators are okay)†.\n\n\nBad:\nGood:\nException: Nested primitive functions (e.g., c(), list(), and rep()) and those used to calculate summary statistics of a data object (e.g., mean(), n(), and length()).\n\n\n● Nested functions should not be nested deeper than two levels (use a pipe instead!)† and each level should be indented two spaces (one tab stop) relative to the parent function.\n\n\nBad:\nGood:\n\n\n\n8.2.3 Arguments in a function\n\n● If you provide four or more arguments to a named function, place each argument on its own line†.\n\n\nBad:\nGood:\nException: When using the c() or list() functions, you may include up to five numeric values.\n\n\n● Logicals: Spell out TRUE and FALSE in a function’s argument.\n\n\nBad:\nGood:\n\n\n● If you modify the default behavior of a function’s argument, include the name of the argument.\n\n\nBad:\nGood:\n\n\n● Character values: Use double-quotes (\"example\") when creating character vectors.\n\n\nBad:\nGood:\n\n\n● Commas should be followed by one trailing space, but not a leading space.\n\n\nBad:\nGood:\nException: More than one space can be added after a comma if it improves the alignment within a code block.\n\n\n\n8.2.4 Whitespace\n\nBad:\n\nc(1, 2)\nlist(1, 2)\n\nGood:\n\nc(1, 2)\n\nlist(1, 2)\n\nException: The library() function: Because it is rarely necessary run or debug a single library loading task!\n\nlibrary(lobstr)\nlibrary(tidyverse)\n\n\n\n○ Code blocks and comments (including section headers)†: This helps differentiate between code and comments.\n\n\nBad:\n\n# My atomic vector:\nc(1, 2)\n# My list:\n\nlist(1, 2)\n\nGood:\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\n○ Comments and section header comments†: This helps section headers stand out.\n\n\nBad:\n\n# My objects ----------------------------------------------\n# My atomic vector:\n\nc(1, 2)\n\nGood:\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n\n\n† The tidyverse style guide gives no recommendations for vertical whitespace in code. I believe that vertical spacing rules defined here really helps differentiate between steps and generate much more readable code.\n\n\n● Horizontal whitespace:\n\n\n○ Include a leading and trailing space for all assignment, arithmetic, and logical operators\n\n\nBad:\n\nmy_vector&lt;-c(1, 2)\n\nmy_vector&lt;- c(1, 2)\n\nmy_vector &lt;-c(1, 2)\n\nmy_vector +1\n\nmy_vector+ 1\n\nGood:\n\nmy_vector &lt;- c(1, 2) + 1\n\nmy_vector + 1\n\nException: More than one space can be added before the = assignment operator if it improves alignment:\n\ntribble(\n  boy   = \"hello\",\n  howdy = \"world\" )\n\n\n\n○ Include a (single) leading space for pipe operators (|&gt;).\n\n\nBad:\n\nmy_vector|&gt;\n  mean()\n\nGood:\n\nmy_vector |&gt;\n  mean()\n\n\n\n○ For multi-line code blocks, indent two spaces (a tab stop) relative to the parent object or process:\n\n\nBad:\n\nmy_vector |&gt;\nmean()\n\nmean(\n    c(1, 1, 2),\nna.rm = TRUE)\n\nlist(\"guitar\",\n     \"bass\",\n     \"drums\")\n\nGood:\n\nmy_vector |&gt;\n  mean()\n\nmean(\n  c(1, 1, 2),\n  na.rm = TRUE)\n\nlist(\n  \"guitar\",\n  \"bass\",\n  \"drums\")\n\n\n\n○ Include a (single) trailing, but not a leading space for:\n\n\n■ Commas: Spacing should be equivalent to the spacing used in regular English writing.\n\n\nBad:\n\nc(1,2)\n\nc(1 ,2)\n\nc(1 , 2)\n\nGood:\n\nc(1, 2)\n\nException: More than one space can be added after a comma if it improves alignment:\n\ntribble(\n  ~ a,     ~ b,\n  \"hello\", \"world\")\n\n\n\n■ The formula operator (~)†\n\n\nBad:\n\nmy_tibble &lt;- \n  tribble(\n    ~boy, ~howdy,\n    1, 2)\n\nGood:\n\nmy_tibble &lt;- \n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n† The tidyverse style guide recommends that “single-sided formulas when the right-hand side is a single identifier” should not be followed by a trailing space. I have removed this requirement simply because examples of more complex right-hand identifiers will not be addressed until Module 5. No code formatting penalty will be enforced when the tidyverse style conditions are met.\n\n\n■ Hash tags and comment text (including section headers)\n\n\nBad:\n\n#My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n#My list:\n\nlist(1, 2)\n\nGood:\n\n# My objects ----------------------------------------------\n\n# My atomic vector:\n\nc(1, 2)\n\n# My list:\n\nlist(1, 2)\n\n\n\n○ Do not include a leading or trailing space between:\n\n\n■ Parentheses† or square bracket operators and adjacent code\n\n\nBad:\n\nmy_vector &lt;- c (1, 2)\n\nmy_vector &lt;- c( 1, 2)\n\nmy_vector &lt;- c(1, 2 )\n\nmy_vector [1]\n\nmy_vector[ 1]\n\nGood:\n\nmy_vector &lt;- c(1, 2)\n\nmy_vector[1]\n\n† The tidyverse style guide recommends including a space with before the parentheses when using the control flow operators for () and if (). These functions will not be addressed until Module 5, thus I have chosen to simplify this style guide by making the rule universal across course content.\n\n\n■ The $ operator\n\n\nBad:\n\nmy_tibble $howdy\n\nmy_tibble$ howdy\n\nGood:\n\nmy_tibble$howdy\n\n\n\n\n8.2.5 Line breaks\n\n● No line of code should exceed 80 characters in width.\n\n\nBad:\n\nbrood_x_cicadas &lt;- c(\"Magicicada cassini\", \"Magicicada septendecim\", \"Magicicada septendecula\")\n\nGood:\n\nbrood_x_cicadas &lt;- \n  c(\"Magicicada cassini\", \"Magicicada septendecim\", \"Magicicada septendecula\")\n\n# Or (even better):\n\nbrood_x_cicadas &lt;- \n  c(\"Magicicada cassini\",\n    \"Magicicada septendecim\", \n    \"Magicicada septendecula\")\n\nException: Wide lines are sometimes unavoidable with long file paths or URLs:\n\npings &lt;- \"https://github.com/kpaxton75/EcolEvol.Manuscript_Optimizing.Trilateration/blob/main/BeepData_Example.rds\"\n\nIn such cases, just do the best you can:\n\npings &lt;- \n  \"https://github.com/kpaxton75/EcolEvol.Manuscript_Optimizing.Trilateration/blob/main/BeepData_Example.rds\"\n\n\n\n● Place no more than one assignment operator (=) or (&lt;-) per line of code†.\n\n\nBad:\n\ngreetings &lt;- rep(c(\"hello world\"), times = 2)\n\nGood:\n\ngreetings &lt;- \n  rep(c(\"hello world\"), times = 2)\n\n\n\n● Place name &lt;- on its own line if the code block is more than one line.\n\n\nBad:\n\nmy_tibble &lt;- tribble(\n  ~ boy, ~ howdy,\n  1, 2)\n\nGood:\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\n\nIf you provide four or more arguments to a named function, place each argument on its own line †.\n\n\nBad:\n\nc(\"guitar\", \"bass\", \"drums\", \"vocals\")\n\nGood:\n\nc(\"guitar\",\n  \"bass\",\n  \"drums\",\n  \"vocals\")\n\nException, c() and list() with numeric values: When using the c() or list() functions, you may include up to five values on the same line if the values being combined are one to three digit numeric values:\n\nc(3, 5, 8, 13, 21)\n\n† The tidyverse style guide recommends a limit to the width of a line but does not recommend a criteria for achieving this.\n\n\nAlways spell out TRUE and FALSE.\n\n\nBad:\n\nmean(\n  c(1, 2, NA),\n  na.rm = T)\n\nGood:\n\nmean(\n  c(1, 2, NA),\n  na.rm = TRUE)\n\n\n\nWith nested functions, include no more than one named function per line (operators are okay)†.\n\n\nBad:\n\nmean(c(1, 2))\n\nGood:\n\nmean(\n  c(1, 2, NA),\n  na.rm = TRUE)\n\nException: If the inner function is used to calculate a summary statistic of the data object (e.g., the functions mean(), n(), and length()):\n\nlist(1, mean(my_vector))\n\nsummarize(my_tibble, n = n())\n\n\n\nWhen chaining together functions with a pipe operator (|&gt;), the chained functions should not occupy the same line of code†.\n\n\nBad:\n\nc(1, 2) |&gt; mean()\n\nmy_tibble |&gt; summarize(n = n())\n\nGood:\n\nc(1, 2) |&gt; \n  mean()\n\nmy_tibble |&gt; \n  summarize(n = n())\n\n† The tidyverse style guide makes an exception with one-step pipes. I have simplified this to include all piped statements.\n\n\n\n8.2.6 Assignments/names\nPlace no more than one assignment operator (=) or (&lt;-) per line of code†.\n\nBad:\n\nmy_instruments &lt;- c(pete = \"guitar\")\n\nc(pete = \"guitar\", john = \"bass\")\n\nGood:\n\nmy_instruments &lt;- \n  c(pete = \"guitar\")\n\nc(pete = \"guitar\", \n  john = \"bass\")\n\n\nOnly use = when providing values assigned to the formals of a function – for assigning to the global environment, use the &lt;- assignment operator:\nBad:\n\n\nmy_tibble =\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nGood:\n\n\nmy_tibble &lt;-\n  tribble(\n    ~ boy, ~ howdy,\n    1, 2)\n\n\nAssigned names should not include a ., should be in lowercase, and spaces between words should be separated by a _ (i.e., snake_case).:\n\nBad:\n\nmy.phrases &lt;-\n  tribble(\n    ~ boyHowdy, ~ HelloWorld,\n    1, 2)\n\nGood:\n\nmy_phrases &lt;-\n  tribble(\n    ~ boy_howdy, ~ hello_world,\n    1, 2)"
  }
]