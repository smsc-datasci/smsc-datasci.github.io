{"title":"Importing & exporting","markdown":{"headingText":"Importing & exporting","containsRefs":false,"markdown":"\n```{r setup, include=FALSE}\nlibrary(tidyverse)\n\nknitr::opts_chunk$set(echo = TRUE,\n                      eval = FALSE)\n```\n\nMaterial covered in this lesson includes:\n\n-   Why work in a project?\n-   Reading data\n-   Explore your data!\n-   Writing data\n\nI rely heavily on the readr package when reading in data. This is one of the **core packages** of the tidyverse. Core tidyverse packages are those that are loaded with `library(tidyverse)`.\n\n## Data for this lesson\n\nWe will use the following real datasets in this lesson:\n\n**Global populations and CO~2~ emissions: API_EN.ATM.CO2E...csv**: These data were compiled by the [World Bank DataBank](https://databank.worldbank.org/home.aspx) and provides information on the emissions of greenhouse gases and the populations of countries around the world. Neither the tabular data nor the name of the file were modified from the original version.\n\n**Iris: iris.csv and iris.rds**: This is Edgar Anderson's famous data set that provides the measurements of flowers of three species of iris, *Iris setosa*, *I. versicolor*, and *I. virginica*. See `?iris` for more information (or the original paper at [this link](https://www.jstor.org/stable/2394164)!).\n\n**Portal rodents: portal.csv and portal.xlsx**. These datasets provide measurements taken in a long term study (the Portal project) on rodent traits in Portal, Arizona. The provided data were collected in a fixed grid established in 1977 and include when an individual was measured, where the measurement occurred, the sex and species of the individual, and their hindfoot length. You can read more about this study and the data they collected at [this link](https://portal.weecology.org/). I intentionally made the data a good bit messier than the original version.\n\n## Why work in a project?\n\nWe will do all of our reading, exploring, and writing data from inside of an RStudio project. Projects have many benefits -- probably the largest of them is that all paths to data and code are supplied relative to your project folder.\n\nFor example, I am working in a project called `data_sci`. The path to my `data_sci` folder (the parent folder of my project) is:\n\n```         \n/Volumes/ssd980/gits/datasci_2023/data_sci\n```\n\nThis project contains a subfolder called `data` and in that folder is a subfolder called `raw`. The full path to the folder `raw` is therefore:\n\n```         \n/Volumes/ssd980/gits/datasci_2023/data_sci/data/raw\n```\n\n*Note: The folder `data` may also be considered a \"child\" of its parent folder, `data_sci`. Likewise, the folder `raw` is a child of its parent folder, `data`.*\n\nThe `raw` data folder contains a *.csv* file called `portal.csv`. The full path to this file is:\n\n```         \n/Volumes/ssd980/gits/datasci_2023/data_sci/data/raw/portal.csv\n```\n\nReading data with a full file path is super cumbersome (**Do not run!**):\n\n```{r, eval = FALSE}\nread_csv(\"/Volumes/ssd980/gits/datasci_2023/data_sci/data/raw/portal.csv\")\n```\n\nThe above has two problems:\n\n-   If we share our code with others or change our folder structure, the file path will need to be modified\n-   That\"s a lot of writing for each file that we read in!\n\nWhen we work within a project, the folder that contains the *.Rproj* file is the working directory for the project. The path to our files within the working directory is written as a **relative file path**. A relative file path is the path to a file *relative* to the working directory. Given that my working directory is the folder `data_sci`, the reading operation above would be written as:\n\n```{r, eval = FALSE}\nread_csv(\"data/raw/portal.csv\")\n```\n\nIn Base R, we can set our working directory using the function `setwd()`. Before RStudio came along, this function was on the top of most of our scripts. It might have look something like (**Do not run!**):\n\n```{r, eval = FALSE}\n# My code for the tutorial: reading, exploring, and writing data\n\n# setup --------------------------------------------------------\n\nlibrary(tidyverse)\n\n# Set working directory:\n\nsetwd(\"/Volumes/ssd980/gits/datasci_2023/data_sci\")\n\n# Read in portal data:\n\nread_csv(\"data/raw/portal.csv\")\n```\n\nThis certainly helps reduce the amount of writing required to read in files. However ...\n\n::: mysecret\n<i class=\"fas fa-user-secret\" style=\"font-size:36px\"></i>  [Never use `setwd()`!]{style=\"font-size: 20px\"}\n\nUsing `setwd()` in your code is dangerous because shared code will never work out-of-the-box. You will have to communicate to others (and your future self) to modify their working directory to match the location on their file systems. Conversely, if you share a **project** with your collaborators, everything will already be in place for them to execute the code.\n\nEven more importantly, you might change your mind about where you want to put your code or files. If you move your files to a new location, your code will no longer run until you modify the path within the `setwd()` function. Your code will be \"broken\". When you use projects, you can move your project anywhere you want in your file system and R will still be able to find your files.\n:::\n\n## Reading data\n\nWe covered this topic in our video \"Reading data\", so this section will serve as a review of the key concepts covered and functions used in that video.\n\n### Read csv files\n\nTabular data are most often stored as comma separated values (*.csv* files). This is a robust format because it does not contain hidden encoding that can sometimes lead to problems (see Excel, below).\n\nIt is best to read in *.csv* files with the *readr* function `read_csv()`:\n\n```{r}\nread_csv(\"data/raw/iris.csv\")\n```\n\nWhen tabular data are read in using `read_csv()`, the data are arranged into a tibble data frame. Additional information about the reading process (i.e., conversion of raw data to a tibble) are printed and may provide clues to potential problems.\n\nConversely, when data read in using the base R function `read.csv()`, no additional information is printed and the data are arranged into a standard data frame (*Note: I chose not to run this because it would have taken up a lot of tutorial real estate!*):\n\n```{r, eval = FALSE}\nread.csv(\"data/raw/iris.csv\")\n```\n\n::: mysecret\n<i class=\"fas fa-user-secret\" style=\"font-size:36px\"></i>   [Do not use `read.csv()`!]{style=\"font-size: 20px\"}\n\nWhenever you use `read.csv()`, additional exploration steps are necessary to search for errors in your data (see Data exploration, below). It is best to be avoided.\n:::\n\n<br>\n\n#### Sometimes reading a csv file is not as easy as it should be ...\n\nWhile encoding is not a problem with *.csv* files, there are often issues with the data that mess up the reading process. For example, the table below represents raw data that I obtained from the World Bank website:\n\n```{r}\nread_csv(\"data/raw/API_EN.ATM.CO2E.PC_DS2_en_csv_v2_2764620.csv\")\n```\n\nHere, we can see that a weird column name was added to the data -- a missing column name was replaced with the unhelpful column name `...3` (see `## New names`). Looking at the data in the tibble above, we can see the source of the problem. It seems that the character values associated with *what should have been the column names* were printed on the second row of the data frame. This suggests that the top rows of the tabular data contained information that should not be a part of the data frame.\n\nAdditional arguments can be passed to `read_csv()` to address this problem (and others; see `?read_csv`):\n\n```{r}\nread_csv(\n  \"data/raw/API_EN.ATM.CO2E.PC_DS2_en_csv_v2_2764620.csv\", \n  skip = 4, \n  skip_empty_rows = FALSE)\n```\n\n::: mysecret\n<i class=\"fas fa-user-secret\" style=\"font-size:36px\"></i>   [Read the help files!]{style=\"font-size: 20px\"}\n\nWhenever you use a function for the first time, or use a function to address a new application, it is a best practice to read the help file for that function (e.g., `?read_lines`). Because functions may change over time, it is also worthwhile to revisit their help files on occasion.\n:::\n\n::: now_you\n{{< fa pen-to-square size=2x >}} [Explore `read_csv()`]{style=\"font-size: 1.25em;\"}\n\nUsing the file above, explore other options for reading in the file with `read_csv()`. Did we have to use the arguments `skip = 4` and `skip_empty_rows = FALSE`? What could you have done instead?\n:::\n\n### Read RDS files\n\nBy far the most straightforward of the file types to read in is the RDS file (but see the caveat associated with these files in \"Writing data\", below). RDS files are data sets that are written in, and written for, program R.\n\nWe can read in an RDS file with the function `read_rds()`:\n\n```{r}\nread_rds(\"data/raw/iris.rds\")\n```\n\nNotice in the above that the first column, species, was read in as a factor. That\"s because an RDS file will read in the data with the class and type in which they were written.\n\nLikewise, an RDS file will maintain all attributes associated with a file:\n\n```{r}\nread_rds(\"data/raw/four_instruments.rds\")\n```\n\nThe character vector above was provided with a *names* attribute. Those names were maintained when the data were written as an RDS *and* when the RDS was read back into R.\n\n### Read Excel files\n\nExcel files can be challenging to read into R but luckily the package `readxl` has made the process fairly straightforward.\n\nThe `readxl` package is part of the tidyverse, but it is not one of the core packages. As such, we have a choice -- we can load the library at the top of our script (i.e., `library(readxl)`) or call functions from the package directly (e.g., `readxl::read_excel`). The double colon operator, `::` is used to access variables in a package. I prefer to use `::` when I only use functions from a package only once or twice in a given script and choose `library([package])` if I use the package often.\n\nEach table in an Excel file is typically stored within worksheets (the tabs on the bottom of the Excel window). Before we read in an Excel file, we should check how many worksheets are present. To do so, we use the function `readxl::excel_sheets()`:\n\n```{r}\nreadxl::excel_sheets(\"data/raw/portal.xlsx\")\n```\n\nThe above returned an atomic character vector with two values, where each value represents the name of a worksheet in the file `portal.xlsx`.\n\nBy default, the function `readxl::read_excel()` will read in *only* the first worksheet in the file:\n\n```{r}\nreadxl::read_excel(\"data/raw/portal.xlsx\")\n```\n\nIf we would like to read in a different worksheet, we can supply the argument `sheet = [name of sheet]` (Note: See `?readxl::read_excel`):\n\n```{r}\nreadxl::read_excel(\"data/raw/portal.xlsx\", sheet = \"site_7\")\n```\n\nIn the above, we notice that there are quite a few bad column names and what is most likely the correct column names are printed on the fourth line of data. We can add a `skip = [number of rows]` argument to skip the first few rows of data:\n\n```{r}\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\", \n  sheet = \"site_7\",\n  skip = 4)\n```\n\nNotice in the above that the column `Date collected` probably should contain a vector of dates but instead it is a character vector, where each value is a set of numbers. That\"s because Excel uses a bunch of encoding to generate dates and stores date values in a different format than is presented on the screen.\n\nWe can specify the types of columns present by providing a character vector of column types.We do this with the `col_types` argument:\n\n```{r}\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\", \n  sheet = \"site_7\",\n  skip = 4,\n  col_types = \n    c(\"text\",\n      \"date\", \n      \"text\",\n      \"text\",\n      \"numeric\"))\n```\n\nThe above returned a warning message that there was a parsing issue in cells B35 and B36 -- neither value could be converted into a date. That\"s because the author of the spreadsheet (which was actually me here, just to exhibit an all-too-common problem) used the cells to record metadata.\n\nThe most straightforward way to address this is to read in only the range of cells that we are interested in. Excel columns are assigned to uppercase letters, the first column we read in, `Plot`, is \"A\" and the last column (counting from the left), `Weight`, is \"E\". Excel rows are assigned to numbers. Based on our warning message, we know that our data end on line 34. Because we skipped the first four rows of data, we know that our column names are listed on line 5. Based on this information we can specify the `range` of cells to read in as:\n\n```{r}\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\", \n  sheet = \"site_7\",\n  range = \"A5:E34\",\n  col_types = \n    c(\"text\",\n      \"date\", \n      \"text\",\n      \"text\",\n      \"numeric\"))\n```\n\nWe can also specify the column names directly. To do so, we read in only the cells that contain data (thus skip the cells that contain column names) and specify our own character vector of column names:\n\n```{r}\nreadxl::read_excel(\n  \"data/raw/portal.xlsx\",\n  sheet = \"site_7\",\n  range = \"A6:E34\",\n  col_names = \n    c(\"plot\",\n      \"date\", \n      \"family\",\n      \"species\", \n      \"weight\"),\n  col_types = \n    c(\"text\",\n      \"date\", \n      \"text\",\n      \"text\",\n      \"numeric\"))\n```\n\n## Data exploration\n\nWhenever we read in data, it is crucial to take the time to explore its class, structure, composition, and the distribution of values.\n\nIf we read in a non-tibble data frame, we should be sure to explore the structure with the function `pillar::glimpse()`. The package `pillar` is part of the **core tidyverse** so, with *tidyverse* loaded you simply need to supply the name of the function and the data frame that you would like to explore:\n\n```{r}\nglimpse(my_df)\n```\n\nIn the above, we see the number of observations (rows) and number of variables (columns). We are also given information on the name and class of each column and the first few values in each.\n\nIn a tibble data frame, this information is printed by default:\n\n```{r}\nmy_tibble\n```\n\nDespite this handy printing of the tibble, we often need to use the number of rows or columns in a data frame programmatically.\n\nWe can determine the number of rows with `nrow()`:\n\n```{r}\nnrow(my_tibble)\n```\n\nAnd determine the number of columns with `ncol()`:\n\n```{r}\nncol(my_tibble)\n```\n\nNote that because a data frame *is* a list, and each column represents a list item, the function `length()` will return the number of columns:\n\n```{r}\nlength(my_tibble)\n```\n\nWe can return the number of rows and columns at the same time using the function `dim()`:\n\n```{r}\ndim(my_tibble)\n```\n\nThis returned an integer vector of dimensions in the rows (the first number) and columns (the second number).\n\nIf you\"ve got too many functions swimming around in your brain, it is worth noting that you can use the function `dim()` and indexing to get the number of rows in the data frame:\n\n```{r}\ndim(my_tibble)[[1]]\n```\n\n... or the number of columns:\n\n```{r}\ndim(my_tibble)[[2]]\n```\n\n### Heads and tails\n\nThe dplyr package, part of the tidyverse core, contains a set of functions that start with the prefix `slice_` that allows you to print a subset of the data (see `?slice`).\n\nWe can print the top row of a data frame using the function `slice_head()`:\n\n```{r}\nslice_head(iris)\n```\n\n... or print the bottom row of a data frame using the function `slice_tail()`:\n\n```{r}\nslice_tail(iris)\n```\n\nWith the argument `n = [number of rows]`, we can subset to the number of rows of our choosing. For example, to view just the first two rows of the data frame, we can use:\n\n```{r}\nslice_head(iris, n = 2)\n```\n\nWe can also subset to a proportion of rows with the argument `prop = [proportion of rows]`. For example, to subset the data to just the last 5 percent of rows we would write:\n\n```{r}\nslice_tail(iris, prop = 0.05)\n```\n\nWe can even slice the data to the row associated with maximum value of a variable:\n\n```{r}\nslice_max(iris, order_by = sepal_length)\n```\n\n... or the minimum value of a variable:\n\n```{r}\nslice_min(iris, order_by = sepal_length)\n```\n\n... or even the 5 rows with that contain the smallest values of a variable:\n\n```{r}\nslice_min(\n  iris, \n  n = 5,\n  order_by = sepal_length)\n```\n\n### Ordering\n\nYou may have noticed when we ran `slice_min()` and `slice_max()` that the tibbles were ordered by the values in the specified columns (thus `order_by =`). Ordering a data frame is a great way to explore the values therein and look for potential problems.\n\nWe can order an entire table by a variable\"s value using `arrange()`:\n\n```{r}\narrange(iris, sepal_length)\n```\n\nThis arranged the table from shortest to longest sepal length values. If we want to order the table from the largest to smallest sepal lengths, we nest the function `desc()` inside of the arrange function:\n\n```{r}\narrange(\n  iris, \n  desc(sepal_length))\n```\n\nFor character values, `arrange()` will sort the table alphabetically:\n\n```{r}\narrange(\n  my_tibble,\n  role)\n```\n\n```{r}\narrange(\n  my_tibble,\n  desc(role))\n```\n\n### Characters and factors\n\nIt is often necessary to know the unique values present in a set of characters or factors.\n\nIf a column is a character of factor vector, we can determine the unique values using, appropriately, the function `unique()`:\n\n```{r}\nunique(iris$species)\n```\n\nThis returned a character vector that only contained the unique values in `iris$species`.\n\nIf the column is a factor, this information can also be extracted using the function `levels()`:\n\n```{r}\nlevels(iris$species)\n```\n\nIf we want to see the number of records associated with a unique character value, we can use the function `table()`:\n\n```{r}\ntable(iris$species)\n```\n\nThe variable `iris$species` is a factor, but this also works on a character vector:\n\n```{r}\ntable(\n  as.character(iris$species))\n```\n\nIn the above, we are given a *very* handy printout of the distribution of the data.\n\n### Statistical summaries\n\nWhen reading in data, it is often useful to look at the summary statistics for the dataset. This can help you find any errors (e.g., potential outliers or NA values). To do so, a good place to start is the function `summary()`:\n\n```{r}\nsummary(iris)\n```\n\n*Note: But see what happens when you run* `summary(my_tibble)` *... the printed summary information for character values isn\"t particularly useful!*\n\nYou can also look at summary statistics individually. This can be especially useful programmatically. I won\"t bore you with a lot of text to describe each one, but here\"s a few to try on your own (*see* `?[function_name]` *if you have any questions about what each does!*):\n\n```{r, eval = FALSE}\nmin(iris$sepal_length)\n\nmax(iris$sepal_length)\n\nmean(iris$sepal_length)\n\nmedian(iris$sepal_length)\n\nvar(iris$sepal_length)\n\nsd(iris$sepal_length)\n```\n\n### A bad habit\n\nThere is one early exploration step that is commonly used that I *do not recommend* ... the function `view()`. This function allows you to view your data as though it were a spreadsheet. Here\"s how it is applied (I have not run it here, but you *may* run it on your own).\n\n```{r, eval = FALSE}\nview(iris)\n```\n\nInvariably, you\"re going to use this function anyways and when I see you do it during our help sessions I will invariably complain -- I might even emit a high-pitched whiny squeel. The student response to my whining is usually something like \"... but I like to see my data.\"\n\nHere\"s the deal: You get very little information by looking directly at the data. There is no indication of column classes, no indication of the number of rows (without scrolling), it is nearly impossible to spot bad character or factor values, and there is little opportunity to explore numeric values (other than ordering). When the data get large, any utility of this tool quickly falls away. It is better to get in the practice of properly exploring the data. As such ...\n\n::: mysecret\n<i class=\"fas fa-user-secret\" style=\"font-size:36px\"></i>   [For God\"s sake, don\"t use `view()`!]{style=\"font-size: 20px\"}\n:::\n\n## Writing data\n\nOur final topic of this section is how to write data to a file. This is quite straightforward, so this section will (actually) be brief for once. To reduce clutter in your data folder, we will remove each file after writing.\n\n### Atomic vectors\n\nThere are two preferred ways to write an atomic vector to a file: as a *.txt* file or as an *.RDS* file.\n\nIf you intend to share your vector outside of program R, saving the vector as a text file is a great way to do it. To do so, use the `write_lines()` function. The first argument of the function is the data to write and the second argument is the relative file path:\n\n```{r}\nwrite_lines(four_instruments, file = \"data/raw/temp.txt\")\n```\n\nWe can use the `list.files()` function to see if the file was written:\n\n```{r}\nlist.files(\"data/raw\", pattern = \"txt\")\n```\n\n... and *really* check to see if it worked by reading the data back in:\n\n```{r}\nread_lines(\"data/raw/temp.txt\")\n```\n\nWe will remove this file with `file.remove()`:\n\n```{r}\nfile.remove(\"data/raw/temp.txt\")\n```\n\n... and check to see if we successfully removed the file:\n\n```{r}\nlist.files(\"data/raw\", pattern = \"txt\")\n```\n\nIf you do not intend to use or share the data outside of R, your best bet is to save the data as an *.RDS* file. For this, we use the function `write_rds()`. Again, the first argument of the function is the data to write and the second argument is the relative file path:\n\n```{r}\n# Write four instruments to file:\n\nwrite_rds(four_instruments, file = \"data/raw/temp.rds\")\n\n# Did it work?\n\nread_rds(\"data/raw/temp.rds\")\n\n# Yup, remove it!\n\nfile.remove(\"data/raw/temp.rds\")\n```\n\n::: mysecret\n<i class=\"fas fa-user-secret\" style=\"font-size:36px\"></i>   [When should I write a file as an RDS?]{style=\"font-size: 20px\"}\n\nReading and writing *.RDS* files is super straightforward in R. As stated previously, you maintain all of the attributes of the data and, frankly, little thought has to be given about the structure of the object. If you\"re happy with it is current structure, you\"re good to go. That being said, **do not** write the file as an *.RDS* if:\n\n-   You intend to share the file with a non-R-user\n-   You plan to work with the file outside of R (hopefully, that won\"t be the case)\n-   The file is too big to fit in your memory (in such cases, R only maintains a pointer to a temporary file stored on your hard drive)\n:::\n\n### Lists\n\nThe **only** way that I save lists is as an *.RDS* file! Let\"s make a list:\n\n```{r}\nmy_list <-\n  list(\n    band = my_tibble,\n    instruments = four_instruments)\n```\n\n... save it as an *.RDS* file:\n\n```{r}\nwrite_rds(my_list, \"data/raw/temp.rds\")\n```\n\n... check to see if it worked:\n\n```{r}\nread_rds(\"data/raw/temp.rds\")\n```\n\n... and remove the file:\n\n```{r}\nfile.remove(\"data/raw/temp.rds\")\n```\n\nI should note that you can use R to write a list as an Excel file (each list item is written to a separate worksheet). I do not recommend doing so, but the package `xlsx` has tools to accomplish this inadvisable task!\n\n### Data frames\n\nThe last kind of data We will write is a tibble. There are three options for doing so:\n\n-   `write.csv`: Base R version (**do not use!**)\n-   `write_csv`: readr version (use this!)\n-   `write_rds`: As above, handy if you don\"t intend to share the file with a non-R-user!\n\nLet\"s start with `write.csv()`. Again, we supply the dataset and a path to the file:\n\n```{r}\nwrite.csv(my_tibble, file = \"data/raw/temp.csv\")\n```\n\n... let\"s see what the above returned:\n\n```{r}\nread_csv(\"data/raw/temp.csv\")\n```\n\nWe can see that this returned an additional column with (rarely useful) row numbers! We can modify this with an argument (`row.names = FALSE`), but there\"s a better way ...\n\nUse `write_csv()`:\n\n```{r}\nwrite_csv(my_tibble, file = \"data/raw/temp.csv\")\n```\n\n... see what the above returned:\n\n```{r}\nread_csv(\"data/raw/temp.csv\")\n```\n\nIt is great! Let\"s delete the file:\n\n```{r}\nfile.remove(\"data/raw/temp.csv\")\n```\n\nAs above, we could have also written the file using `write_rds()` (but see caveats):\n\n```{r}\n# Write as an rds file:\n\nwrite_rds(my_tibble, \"data/raw/temp.rds\")\n\n# Check to see if it worked:\n\nread_rds(\"data/raw/temp.rds\")\n\n# Remove the file:\n\nfile.remove(\"data/raw/temp.rds\")\n```\n\n### A final note\n\nIt is important to consider when a file should be written to your hard drive. Despite the number of files We will use in this course, I write files very rarely. Instead, once I get a raw data file, I generate a script for pre-processing the data and various wrangling steps. Rather than save the processed data, I save and run the script that executes the data processing. The only exception to this is when I work with *very* large files -- files for which the pre-processing script takes a long time to execute (\\> 30 seconds or so). Using this method helps avoid storing multiple versions of the same file and thus improves your organization and workflow.\n\n## Reference material\n\nBelow is some handy reference material for content covered in this lesson.\n\n### Glossary of terms\n\n-   **Assignment** (*noun*): A reference point in your global environment that R can use to retrieve an object located within your computer's memory.\n-   **Assignment** (*verb*): The act of assigning a reference (also called a name, key, binding, or assignment) to your global environment that R can use to retrieve an object located within your computer's memory.\n-   **Code section**: A portion of a script that is delineated by a section header (Windows: Ctrl + Shift + R; Mac: Command + Shift + R)\n-   **Core package**: A package that is loaded when its parent metapackage is loaded.\n-   **Garbage collection**: The process by which R frees up memory by deleting objects that are not named in the global environment\n-   **Global Environment**: The location where object names are stored locally during the current session\n-   **List item**: Individual values or component objects of a list.\n-   **Menu bar**: The bar at the top of the RStudio window\n-   **Pane**: The RStudio window is divided into four sections, called panes\n-   **Relative file path**: The path to a file relative to the working directory\n-   **Session**: Everything you do in RStudio in a single sitting\n-   **Tab**: Each pane has a tab on the top of it. For example, I will often refer to the Environment or History tabs of the workspace pane.\n-   **Working directory**: The location on your computer's operating system where R will attempt to read or write files\n\n### R Studio panes\n\nThroughout this class, I will refer to the panes (sections) of the R Studio window. This graphic should help you remember them:\n\n<img src=\"images/rstudio_panes.png\" style=\"max-width: 100%; height: auto; padding-top: 20px; padding-bottom: 20px\"/></img>\n\n### Keyboard shortcuts\n\nThe Keyboard shortcuts we will use in this lesson are listed below for Windows and Mac operating systems.\n\n::: mysecret\n<i class=\"fas fa-user-secret\" style=\"font-size:36px\"></i>   I strongly suggest using a keyboard shortcut whenever possible. It can be hard to do at first, using your mouse to click a button or typing a few characters is initially **way** easier than remembering the keyboard shortcut. If you force yourself to do it though, you won\"t regret it -- it saves a lot of time in the end.\n:::\n\n| Task                        |       Windows       |         Mac          |\n|:----------------------------|:-------------------:|:--------------------:|\n| Create a new script         | Control + Shift + N | Command + Shift + N  |\n| View all keyboard shortcuts |   Ctrl + Alt + K    | Command + Option + K |\n| Execute code                |    Ctrl + Enter     |   Command + Enter    |\n| Add an assignment operator  |     Alt + Dash      |    Option + Dash     |\n| Save script file            |     Control + S     |     Command + S      |\n| Copy                        |     Control + C     |     Command + C      |\n| Paste                       |     Control + V     |     Command + V      |\n\n: Keyboard shortcuts {.striped .hover}\n\n### Functions used in this lesson\n\n#### Base R functions:\n\n-   `c`\n-   `data.frame`\n-   `dim`\n-   `file.remove`\n-   length\n-   levels\n-   library\n-   list\n-   list.files\n-   ls\n-   max\n-   mean\n-   median\n-   min\n-   nrow\n-   ncol\n-   read.csv (do not use!)\n-   rm\n-   sd\n-   setwd (do not use!)\n-   str\n-   summary\n-   table\n-   unique\n-   var\n-   view (do not use!)\n-   write.csv (do not use!)\n\n#### Tidyverse\n\nWe used the *tidyverse* packages *dplyr*, *readr*, and *tibble* in this lesson. Each of these packages are members of the **core tidyverse** *--* that means that the packages are loaded, by default, with `library(tidyverse)`.\n\n-   dplyr::arrange\n-   dplyr::desc\n-   dplyr::bind_cols\n-   dplyr::slice_head\n-   dplyr::slice_max\n-   dplyr::slice_min\n-   dplyr::slice_tail\n-   readr::read_csv\n-   readr::read_lines\n-   readr::read_rds\n-   readr::write_csv\n-   readr::write_lines\n-   readr::write_rds\n-   readxl::excel_sheets\n-   readxl::read_excel\n-   tibble::tibble\n-   tibble::tribble\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","self-contained":true,"output-file":"reading_writing.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["references.bib"],"editor":"visual","embed-resouces":true,"theme":["cosmo","custom_style.scss"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}